# 开发者指南\n\n## 概述\n\n本指南面向希望参与量化投资研究框架开发或基于框架进行二次开发的开发者。框架采用现代化的技术栈，支持高度可扩展的架构设计。\n\n## 技术栈\n\n### 后端技术\n- **Python 3.11+**: 主要开发语言\n- **FastAPI**: Web框架，提供高性能API服务\n- **SQLAlchemy**: ORM框架，支持多种数据库\n- **PostgreSQL**: 主数据库，存储策略、回测等数据\n- **Redis**: 缓存和消息队列\n- **Celery**: 异步任务处理\n- **Pydantic**: 数据验证和序列化\n- **Alembic**: 数据库迁移工具\n\n### 前端技术\n- **React 18**: 前端框架\n- **TypeScript**: 类型安全的JavaScript\n- **Ant Design**: UI组件库\n- **Recharts**: 图表库\n- **Vite**: 构建工具\n\n### 数据处理\n- **Pandas**: 数据分析和处理\n- **NumPy**: 数值计算\n- **TA-Lib**: 技术指标计算\n- **Scipy**: 科学计算\n- **Scikit-learn**: 机器学习\n\n### 测试工具\n- **Pytest**: 单元测试框架\n- **Pytest-asyncio**: 异步测试支持\n- **Factory Boy**: 测试数据生成\n- **Coverage**: 代码覆盖率\n\n## 项目结构\n\n```\nquant-framework/\n├── quant_framework/           # 主应用代码\n│   ├── api/                   # API路由和控制器\n│   │   ├── routers/          # API路由模块\n│   │   ├── dependencies.py   # 依赖注入\n│   │   └── middleware.py     # 中间件\n│   ├── core/                 # 核心模块\n│   │   ├── config.py         # 配置管理\n│   │   ├── database.py       # 数据库连接\n│   │   ├── security.py       # 安全相关\n│   │   └── exceptions.py     # 异常定义\n│   ├── models/               # 数据模型\n│   │   ├── user.py          # 用户模型\n│   │   ├── strategy.py      # 策略模型\n│   │   └── backtest.py      # 回测模型\n│   ├── services/             # 业务逻辑服务\n│   │   ├── user_service.py  # 用户服务\n│   │   ├── strategy_service.py # 策略服务\n│   │   └── backtest_service.py # 回测服务\n│   ├── data/                 # 数据管理\n│   │   ├── providers/       # 数据源适配器\n│   │   ├── models.py        # 数据模型\n│   │   └── cache.py         # 数据缓存\n│   ├── backtest/            # 回测引擎\n│   │   ├── engine.py        # 回测引擎\n│   │   ├── portfolio.py     # 投资组合管理\n│   │   └── metrics.py       # 性能指标计算\n│   ├── trading/             # 实时交易\n│   │   ├── broker.py        # 券商接口\n│   │   ├── executor.py      # 交易执行器\n│   │   └── risk.py          # 风险控制\n│   ├── jqdata/              # 聚宽兼容层\n│   │   ├── api.py           # API兼容函数\n│   │   ├── data.py          # 数据获取函数\n│   │   └── trading.py       # 交易函数\n│   └── utils/               # 工具函数\n│       ├── datetime.py      # 日期时间工具\n│       ├── validation.py    # 数据验证\n│       └── logging.py       # 日志工具\n├── migrations/              # 数据库迁移文件\n├── tests/                   # 测试代码\n│   ├── unit/               # 单元测试\n│   ├── integration/        # 集成测试\n│   └── fixtures/           # 测试数据\n├── scripts/                # 脚本工具\n│   ├── init_data.py        # 数据初始化\n│   ├── migrate.py          # 数据库迁移\n│   └── backup.py           # 数据备份\n├── docs/                   # 文档\n├── frontend/               # 前端代码\n│   ├── src/\n│   │   ├── components/     # React组件\n│   │   ├── pages/          # 页面组件\n│   │   ├── services/       # API服务\n│   │   └── utils/          # 工具函数\n│   ├── public/             # 静态资源\n│   └── package.json        # 前端依赖\n├── requirements.txt        # Python依赖\n├── pyproject.toml         # 项目配置\n├── docker-compose.yml     # Docker配置\n└── README.md              # 项目说明\n```\n\n## 开发环境搭建\n\n### 1. 环境要求\n\n- Python 3.11+\n- Node.js 18+\n- PostgreSQL 13+\n- Redis 6+\n- Git\n\n### 2. 克隆项目\n\n```bash\ngit clone https://github.com/your-org/quant-framework.git\ncd quant-framework\n```\n\n### 3. 后端环境\n\n```bash\n# 创建虚拟环境\npython -m venv venv\nsource venv/bin/activate  # Linux/Mac\n# 或\nvenv\\Scripts\\activate     # Windows\n\n# 安装依赖\npip install -r requirements.txt\npip install -r requirements-dev.txt\n\n# 安装pre-commit钩子\npre-commit install\n```\n\n### 4. 前端环境\n\n```bash\ncd frontend\nnpm install\ncd ..\n```\n\n### 5. 数据库设置\n\n```bash\n# 创建数据库\ncreatedb quant_framework\n\n# 运行迁移\npython scripts/migrate.py upgrade\n\n# 初始化数据\npython scripts/init_data.py init\n```\n\n### 6. 配置文件\n\n```bash\n# 复制配置模板\ncp .env.example .env\n\n# 编辑配置文件\nvim .env\n```\n\n必要的环境变量：\n```bash\n# 数据库\nDATABASE_URL=postgresql://user:password@localhost:5432/quant_framework\n\n# Redis\nREDIS_URL=redis://localhost:6379/0\n\n# 安全\nSECRET_KEY=your-secret-key-here\nACCESS_TOKEN_EXPIRE_MINUTES=1440\n\n# 数据源\nTUSHARE_TOKEN=your-tushare-token\n\n# 日志\nLOG_LEVEL=INFO\nLOG_FILE=logs/app.log\n```\n\n### 7. 启动服务\n\n```bash\n# 启动后端服务\npython main.py\n\n# 启动前端开发服务器\ncd frontend\nnpm run dev\n```\n\n## 代码规范\n\n### Python代码规范\n\n我们遵循PEP 8和Black代码格式化标准：\n\n```bash\n# 代码格式化\nblack quant_framework/\n\n# 导入排序\nisort quant_framework/\n\n# 代码检查\nflake8 quant_framework/\n\n# 类型检查\nmypy quant_framework/\n```\n\n### 命名约定\n\n- **文件名**: 使用小写字母和下划线 (`user_service.py`)\n- **类名**: 使用驼峰命名 (`UserService`)\n- **函数名**: 使用小写字母和下划线 (`get_user_by_id`)\n- **常量**: 使用大写字母和下划线 (`MAX_RETRY_COUNT`)\n- **私有成员**: 以下划线开头 (`_private_method`)\n\n### 文档字符串\n\n使用Google风格的文档字符串：\n\n```python\ndef calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.0) -> float:\n    \"\"\"计算夏普比率。\n    \n    Args:\n        returns: 收益率序列\n        risk_free_rate: 无风险利率，默认为0\n        \n    Returns:\n        夏普比率值\n        \n    Raises:\n        ValueError: 当收益率序列为空时\n        \n    Example:\n        >>> returns = pd.Series([0.01, 0.02, -0.01, 0.03])\n        >>> sharpe = calculate_sharpe_ratio(returns)\n        >>> print(f\"夏普比率: {sharpe:.2f}\")\n    \"\"\"\n    if returns.empty:\n        raise ValueError(\"收益率序列不能为空\")\n        \n    excess_returns = returns - risk_free_rate\n    return excess_returns.mean() / excess_returns.std() * np.sqrt(252)\n```\n\n## 数据库设计\n\n### 模型定义\n\n使用SQLAlchemy定义数据模型：\n\n```python\nfrom sqlalchemy import Column, Integer, String, DateTime, Float, Text, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.sql import func\n\nBase = declarative_base()\n\nclass Strategy(Base):\n    \"\"\"策略模型。\"\"\"\n    __tablename__ = \"strategies\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(Text)\n    code = Column(Text, nullable=False)\n    parameters = Column(JSON)\n    author_id = Column(Integer, ForeignKey(\"users.id\"))\n    is_public = Column(Boolean, default=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # 关系\n    author = relationship(\"User\", back_populates=\"strategies\")\n    backtests = relationship(\"Backtest\", back_populates=\"strategy\")\n```\n\n### 数据库迁移\n\n使用Alembic管理数据库迁移：\n\n```bash\n# 创建迁移文件\nalembic revision --autogenerate -m \"添加策略表\"\n\n# 应用迁移\nalembic upgrade head\n\n# 回滚迁移\nalembic downgrade -1\n```\n\n迁移文件示例：\n\n```python\n\"\"\"添加策略表\n\nRevision ID: 001\nRevises: \nCreate Date: 2024-01-01 10:00:00.000000\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n# revision identifiers\nrevision = '001'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    op.create_table('strategies',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('name', sa.String(length=100), nullable=False),\n        sa.Column('description', sa.Text(), nullable=True),\n        sa.Column('code', sa.Text(), nullable=False),\n        sa.Column('parameters', sa.JSON(), nullable=True),\n        sa.Column('author_id', sa.Integer(), nullable=True),\n        sa.Column('is_public', sa.Boolean(), nullable=True),\n        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),\n        sa.ForeignKeyConstraint(['author_id'], ['users.id'], ),\n        sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index(op.f('ix_strategies_id'), 'strategies', ['id'], unique=False)\n    op.create_index(op.f('ix_strategies_name'), 'strategies', ['name'], unique=False)\n\ndef downgrade():\n    op.drop_index(op.f('ix_strategies_name'), table_name='strategies')\n    op.drop_index(op.f('ix_strategies_id'), table_name='strategies')\n    op.drop_table('strategies')\n```\n\n## API开发\n\n### 路由定义\n\n使用FastAPI定义API路由：\n\n```python\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\nfrom ..core.database import get_db\nfrom ..core.security import get_current_user\nfrom ..models.user import User\nfrom ..models.strategy import Strategy\nfrom ..schemas.strategy import StrategyCreate, StrategyResponse\nfrom ..services.strategy_service import StrategyService\n\nrouter = APIRouter(prefix=\"/strategies\", tags=[\"strategies\"])\n\n@router.post(\"/\", response_model=StrategyResponse, status_code=status.HTTP_201_CREATED)\nasync def create_strategy(\n    strategy_data: StrategyCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n) -> StrategyResponse:\n    \"\"\"创建新策略。\"\"\"\n    service = StrategyService(db)\n    strategy = await service.create_strategy(strategy_data, current_user.id)\n    return StrategyResponse.from_orm(strategy)\n\n@router.get(\"/\", response_model=List[StrategyResponse])\nasync def list_strategies(\n    skip: int = 0,\n    limit: int = 20,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n) -> List[StrategyResponse]:\n    \"\"\"获取策略列表。\"\"\"\n    service = StrategyService(db)\n    strategies = await service.list_strategies(current_user.id, skip, limit)\n    return [StrategyResponse.from_orm(s) for s in strategies]\n\n@router.get(\"/{strategy_id}\", response_model=StrategyResponse)\nasync def get_strategy(\n    strategy_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n) -> StrategyResponse:\n    \"\"\"获取策略详情。\"\"\"\n    service = StrategyService(db)\n    strategy = await service.get_strategy(strategy_id, current_user.id)\n    if not strategy:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"策略不存在\"\n        )\n    return StrategyResponse.from_orm(strategy)\n```\n\n### 数据验证\n\n使用Pydantic定义数据模式：\n\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\nclass StrategyBase(BaseModel):\n    \"\"\"策略基础模式。\"\"\"\n    name: str = Field(..., min_length=1, max_length=100, description=\"策略名称\")\n    description: Optional[str] = Field(None, max_length=1000, description=\"策略描述\")\n    parameters: Optional[Dict[str, Any]] = Field(None, description=\"策略参数\")\n    is_public: bool = Field(False, description=\"是否公开\")\n\nclass StrategyCreate(StrategyBase):\n    \"\"\"创建策略模式。\"\"\"\n    code: str = Field(..., min_length=1, description=\"策略代码\")\n    \n    @validator('code')\n    def validate_code(cls, v):\n        \"\"\"验证策略代码。\"\"\"\n        if 'initialize' not in v:\n            raise ValueError('策略代码必须包含initialize函数')\n        if 'handle_data' not in v:\n            raise ValueError('策略代码必须包含handle_data函数')\n        return v\n\nclass StrategyResponse(StrategyBase):\n    \"\"\"策略响应模式。\"\"\"\n    id: int\n    author_id: int\n    created_at: datetime\n    updated_at: Optional[datetime]\n    \n    class Config:\n        orm_mode = True\n```\n\n### 服务层\n\n业务逻辑封装在服务层：\n\n```python\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_\nfrom typing import List, Optional\n\nfrom ..models.strategy import Strategy\nfrom ..schemas.strategy import StrategyCreate, StrategyUpdate\nfrom ..core.exceptions import BusinessException\n\nclass StrategyService:\n    \"\"\"策略服务。\"\"\"\n    \n    def __init__(self, db: Session):\n        self.db = db\n    \n    async def create_strategy(self, strategy_data: StrategyCreate, author_id: int) -> Strategy:\n        \"\"\"创建策略。\"\"\"\n        # 验证策略名称唯一性\n        existing = self.db.query(Strategy).filter(\n            and_(Strategy.name == strategy_data.name, Strategy.author_id == author_id)\n        ).first()\n        \n        if existing:\n            raise BusinessException(\"策略名称已存在\")\n        \n        # 验证策略代码\n        await self._validate_strategy_code(strategy_data.code)\n        \n        # 创建策略\n        strategy = Strategy(\n            **strategy_data.dict(),\n            author_id=author_id\n        )\n        \n        self.db.add(strategy)\n        self.db.commit()\n        self.db.refresh(strategy)\n        \n        return strategy\n    \n    async def list_strategies(self, user_id: int, skip: int = 0, limit: int = 20) -> List[Strategy]:\n        \"\"\"获取策略列表。\"\"\"\n        query = self.db.query(Strategy).filter(\n            or_(Strategy.author_id == user_id, Strategy.is_public == True)\n        )\n        \n        return query.offset(skip).limit(limit).all()\n    \n    async def get_strategy(self, strategy_id: int, user_id: int) -> Optional[Strategy]:\n        \"\"\"获取策略详情。\"\"\"\n        return self.db.query(Strategy).filter(\n            and_(\n                Strategy.id == strategy_id,\n                or_(Strategy.author_id == user_id, Strategy.is_public == True)\n            )\n        ).first()\n    \n    async def _validate_strategy_code(self, code: str) -> None:\n        \"\"\"验证策略代码。\"\"\"\n        try:\n            # 编译代码检查语法\n            compile(code, '<strategy>', 'exec')\n            \n            # 检查必要函数\n            namespace = {}\n            exec(code, namespace)\n            \n            if 'initialize' not in namespace:\n                raise BusinessException(\"策略代码必须包含initialize函数\")\n            \n            if 'handle_data' not in namespace:\n                raise BusinessException(\"策略代码必须包含handle_data函数\")\n                \n        except SyntaxError as e:\n            raise BusinessException(f\"策略代码语法错误: {e}\")\n        except Exception as e:\n            raise BusinessException(f\"策略代码验证失败: {e}\")\n```\n\n## 回测引擎开发\n\n### 回测引擎架构\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List\nfrom datetime import datetime, date\nimport pandas as pd\n\nclass BacktestEngine(ABC):\n    \"\"\"回测引擎抽象基类。\"\"\"\n    \n    def __init__(self, strategy_code: str, parameters: Dict[str, Any]):\n        self.strategy_code = strategy_code\n        self.parameters = parameters\n        self.context = BacktestContext()\n        self.portfolio = Portfolio()\n        self.data_manager = DataManager()\n        \n    @abstractmethod\n    async def run(self, start_date: date, end_date: date) -> BacktestResult:\n        \"\"\"运行回测。\"\"\"\n        pass\n    \n    async def initialize_strategy(self) -> None:\n        \"\"\"初始化策略。\"\"\"\n        namespace = {\n            'context': self.context,\n            'set_benchmark': self._set_benchmark,\n            'set_order_cost': self._set_order_cost,\n            **self.parameters\n        }\n        \n        exec(self.strategy_code, namespace)\n        \n        if 'initialize' in namespace:\n            namespace['initialize'](self.context)\n    \n    async def handle_data(self, current_date: date, data: Dict[str, Any]) -> None:\n        \"\"\"处理数据。\"\"\"\n        namespace = {\n            'context': self.context,\n            'data': data,\n            'order': self._order,\n            'order_target_percent': self._order_target_percent,\n            'get_price': self._get_price,\n            'attribute_history': self._attribute_history,\n            **self.parameters\n        }\n        \n        exec(self.strategy_code, namespace)\n        \n        if 'handle_data' in namespace:\n            namespace['handle_data'](self.context, data)\n    \n    def _order(self, security: str, amount: int) -> None:\n        \"\"\"下单。\"\"\"\n        self.portfolio.place_order(security, amount)\n    \n    def _order_target_percent(self, security: str, percent: float) -> None:\n        \"\"\"按比例下单。\"\"\"\n        target_value = self.portfolio.total_value * percent\n        current_value = self.portfolio.get_position_value(security)\n        \n        if target_value > current_value:\n            # 买入\n            amount = (target_value - current_value) / self._get_current_price(security)\n            self.portfolio.place_order(security, int(amount))\n        elif target_value < current_value:\n            # 卖出\n            amount = (current_value - target_value) / self._get_current_price(security)\n            self.portfolio.place_order(security, -int(amount))\n```\n\n### 投资组合管理\n\n```python\nclass Portfolio:\n    \"\"\"投资组合管理。\"\"\"\n    \n    def __init__(self, initial_capital: float = 1000000):\n        self.initial_capital = initial_capital\n        self.cash = initial_capital\n        self.positions: Dict[str, Position] = {}\n        self.trades: List[Trade] = []\n        self.daily_values: List[DailyValue] = []\n    \n    def place_order(self, security: str, amount: int, price: float = None) -> Trade:\n        \"\"\"下单。\"\"\"\n        if price is None:\n            price = self._get_current_price(security)\n        \n        trade_value = abs(amount) * price\n        commission = self._calculate_commission(trade_value)\n        \n        if amount > 0:  # 买入\n            if self.cash < trade_value + commission:\n                raise InsufficientFundsError(\"资金不足\")\n            \n            self.cash -= (trade_value + commission)\n            self._update_position(security, amount, price)\n        else:  # 卖出\n            position = self.positions.get(security)\n            if not position or position.quantity < abs(amount):\n                raise InsufficientPositionError(\"持仓不足\")\n            \n            self.cash += (trade_value - commission)\n            self._update_position(security, amount, price)\n        \n        trade = Trade(\n            security=security,\n            amount=amount,\n            price=price,\n            commission=commission,\n            timestamp=datetime.now()\n        )\n        \n        self.trades.append(trade)\n        return trade\n    \n    def get_total_value(self) -> float:\n        \"\"\"获取总资产。\"\"\"\n        positions_value = sum(\n            pos.quantity * self._get_current_price(pos.security)\n            for pos in self.positions.values()\n        )\n        return self.cash + positions_value\n    \n    def calculate_returns(self) -> pd.Series:\n        \"\"\"计算收益率。\"\"\"\n        values = pd.Series([dv.total_value for dv in self.daily_values])\n        return values.pct_change().dropna()\n```\n\n## 数据管理\n\n### 数据提供者接口\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nimport pandas as pd\n\nclass DataProvider(ABC):\n    \"\"\"数据提供者抽象接口。\"\"\"\n    \n    @abstractmethod\n    async def get_securities(self, exchange: Optional[str] = None) -> List[Security]:\n        \"\"\"获取证券列表。\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_price_data(\n        self, \n        symbol: str, \n        start_date: date, \n        end_date: date,\n        frequency: str = 'daily'\n    ) -> pd.DataFrame:\n        \"\"\"获取价格数据。\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_fundamental_data(\n        self, \n        symbol: str, \n        start_date: date, \n        end_date: date\n    ) -> pd.DataFrame:\n        \"\"\"获取基本面数据。\"\"\"\n        pass\n\nclass TushareProvider(DataProvider):\n    \"\"\"Tushare数据提供者。\"\"\"\n    \n    def __init__(self, token: str):\n        import tushare as ts\n        self.ts = ts\n        ts.set_token(token)\n        self.pro = ts.pro_api()\n    \n    async def get_securities(self, exchange: Optional[str] = None) -> List[Security]:\n        \"\"\"获取证券列表。\"\"\"\n        df = self.pro.stock_basic(\n            exchange=exchange,\n            list_status='L',\n            fields='ts_code,symbol,name,area,industry,list_date'\n        )\n        \n        securities = []\n        for _, row in df.iterrows():\n            security = Security(\n                symbol=row['symbol'],\n                name=row['name'],\n                exchange=exchange or row['ts_code'].split('.')[1],\n                industry=row['industry'],\n                listing_date=pd.to_datetime(row['list_date']).date()\n            )\n            securities.append(security)\n        \n        return securities\n    \n    async def get_price_data(\n        self, \n        symbol: str, \n        start_date: date, \n        end_date: date,\n        frequency: str = 'daily'\n    ) -> pd.DataFrame:\n        \"\"\"获取价格数据。\"\"\"\n        ts_code = self._convert_symbol(symbol)\n        \n        df = self.pro.daily(\n            ts_code=ts_code,\n            start_date=start_date.strftime('%Y%m%d'),\n            end_date=end_date.strftime('%Y%m%d')\n        )\n        \n        # 数据清洗和格式化\n        df['trade_date'] = pd.to_datetime(df['trade_date'])\n        df = df.sort_values('trade_date')\n        df = df.set_index('trade_date')\n        \n        # 重命名列\n        df = df.rename(columns={\n            'open': 'open',\n            'high': 'high', \n            'low': 'low',\n            'close': 'close',\n            'vol': 'volume',\n            'amount': 'amount'\n        })\n        \n        return df[['open', 'high', 'low', 'close', 'volume', 'amount']]\n```\n\n### 数据缓存\n\n```python\nimport redis\nimport pickle\nfrom typing import Any, Optional\nfrom datetime import timedelta\n\nclass DataCache:\n    \"\"\"数据缓存管理。\"\"\"\n    \n    def __init__(self, redis_url: str):\n        self.redis = redis.from_url(redis_url)\n    \n    async def get(self, key: str) -> Optional[Any]:\n        \"\"\"获取缓存数据。\"\"\"\n        try:\n            data = self.redis.get(key)\n            if data:\n                return pickle.loads(data)\n        except Exception as e:\n            logger.warning(f\"缓存读取失败: {e}\")\n        return None\n    \n    async def set(self, key: str, value: Any, expire: timedelta = None) -> None:\n        \"\"\"设置缓存数据。\"\"\"\n        try:\n            data = pickle.dumps(value)\n            if expire:\n                self.redis.setex(key, expire, data)\n            else:\n                self.redis.set(key, data)\n        except Exception as e:\n            logger.warning(f\"缓存写入失败: {e}\")\n    \n    async def delete(self, key: str) -> None:\n        \"\"\"删除缓存数据。\"\"\"\n        try:\n            self.redis.delete(key)\n        except Exception as e:\n            logger.warning(f\"缓存删除失败: {e}\")\n    \n    def generate_key(self, prefix: str, **kwargs) -> str:\n        \"\"\"生成缓存键。\"\"\"\n        parts = [prefix]\n        for k, v in sorted(kwargs.items()):\n            parts.append(f\"{k}:{v}\")\n        return \":\".join(parts)\n```\n\n## 测试\n\n### 单元测试\n\n```python\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom datetime import date\n\nfrom quant_framework.services.strategy_service import StrategyService\nfrom quant_framework.schemas.strategy import StrategyCreate\nfrom quant_framework.core.exceptions import BusinessException\n\nclass TestStrategyService:\n    \"\"\"策略服务测试。\"\"\"\n    \n    @pytest.fixture\n    def mock_db(self):\n        return Mock()\n    \n    @pytest.fixture\n    def strategy_service(self, mock_db):\n        return StrategyService(mock_db)\n    \n    @pytest.fixture\n    def valid_strategy_data(self):\n        return StrategyCreate(\n            name=\"测试策略\",\n            description=\"这是一个测试策略\",\n            code=\"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n\ndef handle_data(context, data):\n    order_target_percent(context.security, 1.0)\n\"\"\",\n            parameters={\"window\": 20}\n        )\n    \n    async def test_create_strategy_success(self, strategy_service, mock_db, valid_strategy_data):\n        \"\"\"测试成功创建策略。\"\"\"\n        # 模拟数据库查询返回None（策略名称不存在）\n        mock_db.query.return_value.filter.return_value.first.return_value = None\n        \n        # 执行创建策略\n        result = await strategy_service.create_strategy(valid_strategy_data, user_id=1)\n        \n        # 验证结果\n        assert result is not None\n        mock_db.add.assert_called_once()\n        mock_db.commit.assert_called_once()\n    \n    async def test_create_strategy_duplicate_name(self, strategy_service, mock_db, valid_strategy_data):\n        \"\"\"测试创建重复名称策略。\"\"\"\n        # 模拟数据库查询返回已存在的策略\n        mock_db.query.return_value.filter.return_value.first.return_value = Mock()\n        \n        # 验证抛出异常\n        with pytest.raises(BusinessException, match=\"策略名称已存在\"):\n            await strategy_service.create_strategy(valid_strategy_data, user_id=1)\n    \n    async def test_create_strategy_invalid_code(self, strategy_service, mock_db):\n        \"\"\"测试创建无效代码策略。\"\"\"\n        invalid_strategy_data = StrategyCreate(\n            name=\"无效策略\",\n            code=\"def invalid_function(): pass\",  # 缺少必要函数\n            parameters={}\n        )\n        \n        mock_db.query.return_value.filter.return_value.first.return_value = None\n        \n        with pytest.raises(BusinessException, match=\"策略代码必须包含initialize函数\"):\n            await strategy_service.create_strategy(invalid_strategy_data, user_id=1)\n```\n\n### 集成测试\n\n```python\nimport pytest\nfrom httpx import AsyncClient\nfrom datetime import date\n\nfrom quant_framework.main import app\nfrom quant_framework.core.database import get_db\nfrom tests.conftest import override_get_db, test_db\n\nclass TestStrategyAPI:\n    \"\"\"策略API集成测试。\"\"\"\n    \n    @pytest.fixture\n    async def client(self):\n        app.dependency_overrides[get_db] = override_get_db\n        async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n            yield ac\n    \n    @pytest.fixture\n    async def auth_headers(self, client):\n        # 创建测试用户并获取token\n        response = await client.post(\"/api/v1/auth/register\", json={\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"testpass123\",\n            \"full_name\": \"Test User\"\n        })\n        \n        login_response = await client.post(\"/api/v1/auth/login\", json={\n            \"username\": \"testuser\",\n            \"password\": \"testpass123\"\n        })\n        \n        token = login_response.json()[\"access_token\"]\n        return {\"Authorization\": f\"Bearer {token}\"}\n    \n    async def test_create_strategy(self, client, auth_headers):\n        \"\"\"测试创建策略API。\"\"\"\n        strategy_data = {\n            \"name\": \"测试策略\",\n            \"description\": \"API测试策略\",\n            \"code\": \"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n\ndef handle_data(context, data):\n    order_target_percent(context.security, 1.0)\n\"\"\",\n            \"parameters\": {\"window\": 20}\n        }\n        \n        response = await client.post(\n            \"/api/v1/strategies/\",\n            json=strategy_data,\n            headers=auth_headers\n        )\n        \n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"测试策略\"\n        assert data[\"id\"] is not None\n    \n    async def test_list_strategies(self, client, auth_headers):\n        \"\"\"测试获取策略列表API。\"\"\"\n        response = await client.get(\n            \"/api/v1/strategies/\",\n            headers=auth_headers\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert isinstance(data, list)\n    \n    async def test_get_strategy(self, client, auth_headers):\n        \"\"\"测试获取策略详情API。\"\"\"\n        # 先创建一个策略\n        create_response = await client.post(\n            \"/api/v1/strategies/\",\n            json={\n                \"name\": \"详情测试策略\",\n                \"code\": \"def initialize(context): pass\\ndef handle_data(context, data): pass\"\n            },\n            headers=auth_headers\n        )\n        \n        strategy_id = create_response.json()[\"id\"]\n        \n        # 获取策略详情\n        response = await client.get(\n            f\"/api/v1/strategies/{strategy_id}\",\n            headers=auth_headers\n        )\n        \n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"id\"] == strategy_id\n        assert data[\"name\"] == \"详情测试策略\"\n```\n\n### 性能测试\n\n```python\nimport pytest\nimport asyncio\nfrom datetime import date, timedelta\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom quant_framework.backtest.engine import BacktestEngine\nfrom quant_framework.data.providers.tushare_provider import TushareProvider\n\nclass TestPerformance:\n    \"\"\"性能测试。\"\"\"\n    \n    @pytest.mark.performance\n    async def test_backtest_performance(self):\n        \"\"\"测试回测性能。\"\"\"\n        strategy_code = \"\"\"\ndef initialize(context):\n    context.stocks = ['000001.XSHE', '000002.XSHE', '600000.XSHG']\n    \ndef handle_data(context, data):\n    for stock in context.stocks:\n        order_target_percent(stock, 0.33)\n\"\"\"\n        \n        engine = BacktestEngine(strategy_code, {})\n        \n        start_time = asyncio.get_event_loop().time()\n        \n        result = await engine.run(\n            start_date=date(2023, 1, 1),\n            end_date=date(2023, 12, 31)\n        )\n        \n        end_time = asyncio.get_event_loop().time()\n        duration = end_time - start_time\n        \n        # 验证性能要求（1年回测应在30秒内完成）\n        assert duration < 30, f\"回测耗时过长: {duration:.2f}秒\"\n        assert result is not None\n    \n    @pytest.mark.performance\n    async def test_concurrent_backtests(self):\n        \"\"\"测试并发回测性能。\"\"\"\n        strategy_code = \"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n    \ndef handle_data(context, data):\n    order_target_percent(context.security, 1.0)\n\"\"\"\n        \n        async def run_backtest(i):\n            engine = BacktestEngine(strategy_code, {\"id\": i})\n            return await engine.run(\n                start_date=date(2023, 1, 1),\n                end_date=date(2023, 6, 30)\n            )\n        \n        start_time = asyncio.get_event_loop().time()\n        \n        # 并发运行5个回测\n        tasks = [run_backtest(i) for i in range(5)]\n        results = await asyncio.gather(*tasks)\n        \n        end_time = asyncio.get_event_loop().time()\n        duration = end_time - start_time\n        \n        # 验证并发性能\n        assert len(results) == 5\n        assert all(r is not None for r in results)\n        assert duration < 60, f\"并发回测耗时过长: {duration:.2f}秒\"\n```\n\n## 部署\n\n### Docker部署\n\n```dockerfile\n# Dockerfile\nFROM python:3.11-slim\n\n# 设置工作目录\nWORKDIR /app\n\n# 安装系统依赖\nRUN apt-get update && apt-get install -y \\\n    gcc \\\n    g++ \\\n    libpq-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 复制依赖文件\nCOPY requirements.txt .\n\n# 安装Python依赖\nRUN pip install --no-cache-dir -r requirements.txt\n\n# 复制应用代码\nCOPY . .\n\n# 设置环境变量\nENV PYTHONPATH=/app\nENV PYTHONUNBUFFERED=1\n\n# 暴露端口\nEXPOSE 8000\n\n# 启动命令\nCMD [\"uvicorn\", \"quant_framework.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=postgresql://postgres:password@db:5432/quant_framework\n      - REDIS_URL=redis://redis:6379/0\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./logs:/app/logs\n  \n  db:\n    image: postgres:13\n    environment:\n      - POSTGRES_DB=quant_framework\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n  \n  redis:\n    image: redis:6-alpine\n    ports:\n      - \"6379:6379\"\n  \n  worker:\n    build: .\n    command: celery -A quant_framework.core.celery worker --loglevel=info\n    environment:\n      - DATABASE_URL=postgresql://postgres:password@db:5432/quant_framework\n      - REDIS_URL=redis://redis:6379/0\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./logs:/app/logs\n\nvolumes:\n  postgres_data:\n```\n\n### Kubernetes部署\n\n```yaml\n# k8s/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: quant-framework\n  labels:\n    app: quant-framework\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: quant-framework\n  template:\n    metadata:\n      labels:\n        app: quant-framework\n    spec:\n      containers:\n      - name: app\n        image: quant-framework:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: quant-framework-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: quant-framework-secrets\n              key: redis-url\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: quant-framework-service\nspec:\n  selector:\n    app: quant-framework\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8000\n  type: LoadBalancer\n```\n\n## 监控和日志\n\n### 日志配置\n\n```python\n# quant_framework/core/logging.py\nimport logging\nimport logging.config\nfrom pathlib import Path\n\nLOGGING_CONFIG = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        },\n        \"detailed\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(module)s - %(funcName)s - %(message)s\",\n        },\n    },\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"level\": \"INFO\",\n            \"formatter\": \"default\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n        \"file\": {\n            \"class\": \"logging.handlers.RotatingFileHandler\",\n            \"level\": \"DEBUG\",\n            \"formatter\": \"detailed\",\n            \"filename\": \"logs/app.log\",\n            \"maxBytes\": 10485760,  # 10MB\n            \"backupCount\": 5,\n        },\n        \"error_file\": {\n            \"class\": \"logging.handlers.RotatingFileHandler\",\n            \"level\": \"ERROR\",\n            \"formatter\": \"detailed\",\n            \"filename\": \"logs/error.log\",\n            \"maxBytes\": 10485760,\n            \"backupCount\": 5,\n        },\n    },\n    \"loggers\": {\n        \"quant_framework\": {\n            \"level\": \"DEBUG\",\n            \"handlers\": [\"console\", \"file\", \"error_file\"],\n            \"propagate\": False,\n        },\n        \"uvicorn\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"console\", \"file\"],\n            \"propagate\": False,\n        },\n    },\n    \"root\": {\n        \"level\": \"INFO\",\n        \"handlers\": [\"console\", \"file\"],\n    },\n}\n\ndef setup_logging():\n    \"\"\"设置日志配置。\"\"\"\n    # 确保日志目录存在\n    Path(\"logs\").mkdir(exist_ok=True)\n    \n    # 应用日志配置\n    logging.config.dictConfig(LOGGING_CONFIG)\n```\n\n### 性能监控\n\n```python\n# quant_framework/core/monitoring.py\nimport time\nimport psutil\nfrom typing import Dict, Any\nfrom prometheus_client import Counter, Histogram, Gauge, generate_latest\n\n# 定义指标\nREQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])\nREQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')\nBACKTEST_COUNT = Counter('backtests_total', 'Total backtests', ['status'])\nBACKTEST_DURATION = Histogram('backtest_duration_seconds', 'Backtest duration')\nSYSTEM_CPU_USAGE = Gauge('system_cpu_usage_percent', 'System CPU usage')\nSYSTEM_MEMORY_USAGE = Gauge('system_memory_usage_percent', 'System memory usage')\n\nclass PerformanceMonitor:\n    \"\"\"性能监控。\"\"\"\n    \n    @staticmethod\n    def record_request(method: str, endpoint: str, status: int, duration: float):\n        \"\"\"记录HTTP请求指标。\"\"\"\n        REQUEST_COUNT.labels(method=method, endpoint=endpoint, status=status).inc()\n        REQUEST_DURATION.observe(duration)\n    \n    @staticmethod\n    def record_backtest(status: str, duration: float):\n        \"\"\"记录回测指标。\"\"\"\n        BACKTEST_COUNT.labels(status=status).inc()\n        BACKTEST_DURATION.observe(duration)\n    \n    @staticmethod\n    def update_system_metrics():\n        \"\"\"更新系统指标。\"\"\"\n        SYSTEM_CPU_USAGE.set(psutil.cpu_percent())\n        SYSTEM_MEMORY_USAGE.set(psutil.virtual_memory().percent)\n    \n    @staticmethod\n    def get_metrics() -> str:\n        \"\"\"获取Prometheus格式的指标。\"\"\"\n        return generate_latest()\n```\n\n## 贡献指南\n\n### 开发流程\n\n1. **Fork项目**: 在GitHub上fork项目到你的账户\n2. **创建分支**: 为新功能或修复创建分支\n   ```bash\n   git checkout -b feature/new-feature\n   ```\n3. **开发代码**: 按照代码规范开发\n4. **编写测试**: 为新功能编写测试\n5. **运行测试**: 确保所有测试通过\n   ```bash\n   pytest tests/\n   ```\n6. **提交代码**: 提交代码并推送到你的fork\n   ```bash\n   git commit -m \"feat: 添加新功能\"\n   git push origin feature/new-feature\n   ```\n7. **创建PR**: 在GitHub上创建Pull Request\n\n### 提交信息规范\n\n使用[Conventional Commits](https://www.conventionalcommits.org/)规范：\n\n- `feat`: 新功能\n- `fix`: 修复bug\n- `docs`: 文档更新\n- `style`: 代码格式化\n- `refactor`: 代码重构\n- `test`: 测试相关\n- `chore`: 构建过程或辅助工具的变动\n\n示例：\n```\nfeat(backtest): 添加多因子回测支持\n\n- 支持多个因子同时回测\n- 添加因子权重配置\n- 优化回测性能\n\nCloses #123\n```\n\n### 代码审查\n\n所有代码都需要经过审查：\n\n1. **自动检查**: CI会自动运行测试和代码检查\n2. **人工审查**: 至少需要一个维护者的审查\n3. **修改建议**: 根据审查意见修改代码\n4. **合并代码**: 审查通过后合并到主分支\n\n---\n\n*本开发者指南持续更新中，欢迎贡献改进建议。*