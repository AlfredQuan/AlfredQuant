# 策略开发教程\n\n## 概述\n\n本教程将指导你从零开始开发量化投资策略，包括策略设计、编码实现、回测验证和优化改进的完整流程。\n\n## 策略开发基础\n\n### 策略结构\n\n每个策略都包含以下核心函数：\n\n```python\ndef initialize(context):\n    \"\"\"策略初始化函数，只在策略开始时运行一次。\"\"\"\n    pass\n\ndef handle_data(context, data):\n    \"\"\"数据处理函数，每个交易日都会运行。\"\"\"\n    pass\n\ndef before_trading_start(context):\n    \"\"\"开盘前运行的函数（可选）。\"\"\"\n    pass\n\ndef after_trading_end(context):\n    \"\"\"收盘后运行的函数（可选）。\"\"\"\n    pass\n```\n\n### Context对象\n\n`context`对象用于存储策略的状态信息：\n\n```python\ndef initialize(context):\n    # 设置股票池\n    context.stocks = ['000001.XSHE', '000002.XSHE', '600000.XSHG']\n    \n    # 设置策略参数\n    context.short_window = 5\n    context.long_window = 20\n    \n    # 设置基准\n    set_benchmark('000300.XSHG')\n    \n    # 设置手续费\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n```\n\n## 入门示例：买入持有策略\n\n让我们从最简单的买入持有策略开始：\n\n```python\ndef initialize(context):\n    \"\"\"初始化策略。\"\"\"\n    # 选择一只股票\n    context.security = '000001.XSHE'  # 平安银行\n    \n    # 设置基准为沪深300\n    set_benchmark('000300.XSHG')\n    \n    # 设置手续费\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n    \n    # 标记是否已买入\n    context.has_bought = False\n\ndef handle_data(context, data):\n    \"\"\"处理数据。\"\"\"\n    security = context.security\n    \n    # 如果还没买入，则买入\n    if not context.has_bought:\n        # 全仓买入\n        order_target_percent(security, 1.0)\n        context.has_bought = True\n        log.info(f\"买入 {security}\")\n```\n\n这个策略非常简单：在第一个交易日买入平安银行股票，然后一直持有。\n\n## 进阶示例：移动平均策略\n\n移动平均策略是经典的技术分析策略：\n\n```python\ndef initialize(context):\n    \"\"\"初始化策略。\"\"\"\n    # 设置股票\n    context.security = '000001.XSHE'\n    \n    # 设置移动平均参数\n    context.short_window = 5   # 短期均线\n    context.long_window = 20   # 长期均线\n    \n    # 设置基准\n    set_benchmark('000300.XSHG')\n    \n    # 设置手续费\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n\ndef handle_data(context, data):\n    \"\"\"处理数据。\"\"\"\n    security = context.security\n    \n    # 获取历史价格数据\n    hist = attribute_history(security, context.long_window, '1d', ['close'])\n    \n    # 如果数据不足，跳过\n    if len(hist) < context.long_window:\n        return\n    \n    # 计算移动平均线\n    short_ma = hist['close'][-context.short_window:].mean()\n    long_ma = hist['close'].mean()\n    \n    # 获取当前价格\n    current_price = data[security].close\n    \n    # 获取当前持仓\n    current_position = context.portfolio.positions[security]\n    \n    # 交易逻辑\n    if short_ma > long_ma and current_position.total_amount == 0:\n        # 金叉且无持仓，买入\n        order_target_percent(security, 1.0)\n        log.info(f\"金叉信号，买入 {security}，价格: {current_price:.2f}\")\n        \n    elif short_ma < long_ma and current_position.total_amount > 0:\n        # 死叉且有持仓，卖出\n        order_target_percent(security, 0)\n        log.info(f\"死叉信号，卖出 {security}，价格: {current_price:.2f}\")\n```\n\n## 多股票策略示例\n\n让我们开发一个多股票轮动策略：\n\n```python\ndef initialize(context):\n    \"\"\"初始化策略。\"\"\"\n    # 设置股票池（银行股）\n    context.stocks = [\n        '000001.XSHE',  # 平安银行\n        '600000.XSHG',  # 浦发银行\n        '600036.XSHG',  # 招商银行\n        '601166.XSHG',  # 兴业银行\n        '000002.XSHE',  # 万科A\n    ]\n    \n    # 设置参数\n    context.lookback_window = 20  # 回看窗口\n    context.top_n = 3  # 选择前N只股票\n    \n    # 设置基准\n    set_benchmark('000300.XSHG')\n    \n    # 设置手续费\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n    \n    # 设置调仓频率（每月调仓一次）\n    run_monthly(rebalance, monthday=1)\n\ndef rebalance(context):\n    \"\"\"调仓函数。\"\"\"\n    # 计算每只股票的动量得分\n    scores = {}\n    \n    for stock in context.stocks:\n        # 获取历史价格\n        hist = attribute_history(stock, context.lookback_window + 1, '1d', ['close'])\n        \n        if len(hist) < context.lookback_window + 1:\n            continue\n            \n        # 计算动量得分（过去20天的收益率）\n        returns = hist['close'].pct_change().dropna()\n        momentum_score = returns.mean()\n        scores[stock] = momentum_score\n    \n    # 按得分排序，选择前N只\n    sorted_stocks = sorted(scores.items(), key=lambda x: x[1], reverse=True)\n    selected_stocks = [stock for stock, score in sorted_stocks[:context.top_n]]\n    \n    log.info(f\"选中股票: {selected_stocks}\")\n    \n    # 等权重分配\n    target_weight = 1.0 / len(selected_stocks) if selected_stocks else 0\n    \n    # 调仓\n    for stock in context.stocks:\n        if stock in selected_stocks:\n            order_target_percent(stock, target_weight)\n        else:\n            order_target_percent(stock, 0)\n\ndef handle_data(context, data):\n    \"\"\"处理数据。\"\"\"\n    # 在这个策略中，主要逻辑在rebalance函数中\n    pass\n```\n\n## 技术指标策略\n\n使用技术指标开发策略：\n\n```python\nimport talib\n\ndef initialize(context):\n    \"\"\"初始化策略。\"\"\"\n    context.security = '000001.XSHE'\n    \n    # RSI参数\n    context.rsi_window = 14\n    context.rsi_overbought = 70\n    context.rsi_oversold = 30\n    \n    # MACD参数\n    context.macd_fast = 12\n    context.macd_slow = 26\n    context.macd_signal = 9\n    \n    set_benchmark('000300.XSHG')\n    \n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n\ndef handle_data(context, data):\n    \"\"\"处理数据。\"\"\"\n    security = context.security\n    \n    # 获取足够的历史数据\n    hist = attribute_history(security, 60, '1d', ['close', 'high', 'low'])\n    \n    if len(hist) < 60:\n        return\n    \n    # 计算技术指标\n    close_prices = hist['close'].values\n    high_prices = hist['high'].values\n    low_prices = hist['low'].values\n    \n    # RSI指标\n    rsi = talib.RSI(close_prices, timeperiod=context.rsi_window)\n    current_rsi = rsi[-1]\n    \n    # MACD指标\n    macd, macd_signal, macd_hist = talib.MACD(\n        close_prices,\n        fastperiod=context.macd_fast,\n        slowperiod=context.macd_slow,\n        signalperiod=context.macd_signal\n    )\n    \n    current_macd = macd[-1]\n    current_signal = macd_signal[-1]\n    prev_macd = macd[-2]\n    prev_signal = macd_signal[-2]\n    \n    # 获取当前持仓\n    current_position = context.portfolio.positions[security]\n    \n    # 交易逻辑\n    # 买入条件：RSI超卖 且 MACD金叉\n    buy_signal = (\n        current_rsi < context.rsi_oversold and\n        current_macd > current_signal and\n        prev_macd <= prev_signal\n    )\n    \n    # 卖出条件：RSI超买 或 MACD死叉\n    sell_signal = (\n        current_rsi > context.rsi_overbought or\n        (current_macd < current_signal and prev_macd >= prev_signal)\n    )\n    \n    if buy_signal and current_position.total_amount == 0:\n        order_target_percent(security, 1.0)\n        log.info(f\"买入信号 - RSI: {current_rsi:.2f}, MACD: {current_macd:.4f}\")\n        \n    elif sell_signal and current_position.total_amount > 0:\n        order_target_percent(security, 0)\n        log.info(f\"卖出信号 - RSI: {current_rsi:.2f}, MACD: {current_macd:.4f}\")\n```\n\n## 基本面策略\n\n基于基本面数据的策略：\n\n```python\ndef initialize(context):\n    \"\"\"初始化策略。\"\"\"\n    # 设置股票池（全A股）\n    context.stocks = get_all_securities(['stock']).index.tolist()\n    \n    # 过滤掉ST股票和新股\n    context.stocks = [\n        stock for stock in context.stocks \n        if not get_security_info(stock).display_name.startswith('ST')\n    ]\n    \n    # 设置参数\n    context.max_positions = 10  # 最大持仓数量\n    \n    set_benchmark('000300.XSHG')\n    \n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n    \n    # 每月调仓\n    run_monthly(rebalance, monthday=1)\n\ndef rebalance(context):\n    \"\"\"调仓函数。\"\"\"\n    # 获取基本面数据\n    q = query(\n        valuation.code,\n        valuation.pe_ratio,\n        valuation.pb_ratio,\n        balance.total_assets,\n        income.total_revenue,\n        income.net_profit\n    ).filter(\n        valuation.code.in_(context.stocks),\n        valuation.pe_ratio > 0,\n        valuation.pb_ratio > 0,\n        balance.total_assets > 0,\n        income.total_revenue > 0,\n        income.net_profit > 0\n    )\n    \n    df = get_fundamentals(q)\n    \n    if df.empty:\n        return\n    \n    # 计算综合得分\n    # PE越小越好，PB越小越好，净利润越大越好\n    df['pe_score'] = 1 / df['pe_ratio']\n    df['pb_score'] = 1 / df['pb_ratio']\n    df['profit_score'] = df['net_profit'] / df['net_profit'].max()\n    \n    # 综合得分（可以调整权重）\n    df['total_score'] = (\n        df['pe_score'] * 0.3 +\n        df['pb_score'] * 0.3 +\n        df['profit_score'] * 0.4\n    )\n    \n    # 选择得分最高的股票\n    df = df.sort_values('total_score', ascending=False)\n    selected_stocks = df.head(context.max_positions)['code'].tolist()\n    \n    log.info(f\"选中股票: {selected_stocks}\")\n    \n    # 等权重分配\n    target_weight = 1.0 / len(selected_stocks) if selected_stocks else 0\n    \n    # 调仓\n    for stock in context.stocks:\n        if stock in selected_stocks:\n            order_target_percent(stock, target_weight)\n        else:\n            order_target_percent(stock, 0)\n\ndef handle_data(context, data):\n    \"\"\"处理数据。\"\"\"\n    pass\n```\n\n## 风险控制\n\n在策略中加入风险控制机制：\n\n```python\ndef initialize(context):\n    \"\"\"初始化策略。\"\"\"\n    context.security = '000001.XSHE'\n    \n    # 风险控制参数\n    context.max_drawdown = 0.1  # 最大回撤10%\n    context.stop_loss = 0.05    # 止损5%\n    context.take_profit = 0.15  # 止盈15%\n    \n    # 记录最高净值\n    context.max_net_value = 1.0\n    \n    # 记录买入价格\n    context.buy_price = None\n    \n    set_benchmark('000300.XSHG')\n    \n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n\ndef handle_data(context, data):\n    \"\"\"处理数据。\"\"\"\n    security = context.security\n    current_price = data[security].close\n    \n    # 更新最高净值\n    current_net_value = context.portfolio.total_value / context.portfolio.starting_cash\n    if current_net_value > context.max_net_value:\n        context.max_net_value = current_net_value\n    \n    # 检查最大回撤\n    current_drawdown = (context.max_net_value - current_net_value) / context.max_net_value\n    if current_drawdown > context.max_drawdown:\n        # 超过最大回撤，清仓\n        order_target_percent(security, 0)\n        log.info(f\"触发最大回撤控制，清仓。当前回撤: {current_drawdown:.2%}\")\n        return\n    \n    # 获取当前持仓\n    current_position = context.portfolio.positions[security]\n    \n    if current_position.total_amount > 0:\n        # 有持仓，检查止损止盈\n        if context.buy_price is not None:\n            # 计算收益率\n            return_rate = (current_price - context.buy_price) / context.buy_price\n            \n            if return_rate <= -context.stop_loss:\n                # 触发止损\n                order_target_percent(security, 0)\n                log.info(f\"触发止损，卖出。收益率: {return_rate:.2%}\")\n                context.buy_price = None\n                return\n                \n            elif return_rate >= context.take_profit:\n                # 触发止盈\n                order_target_percent(security, 0)\n                log.info(f\"触发止盈，卖出。收益率: {return_rate:.2%}\")\n                context.buy_price = None\n                return\n    \n    # 策略逻辑（这里用简单的移动平均）\n    hist = attribute_history(security, 20, '1d', ['close'])\n    if len(hist) < 20:\n        return\n    \n    ma20 = hist['close'].mean()\n    \n    if current_position.total_amount == 0 and current_price > ma20 * 1.02:\n        # 无持仓且价格突破均线，买入\n        order_target_percent(security, 1.0)\n        context.buy_price = current_price\n        log.info(f\"买入信号，价格: {current_price:.2f}\")\n```\n\n## 策略优化\n\n### 参数优化\n\n```python\n# 在策略中定义可优化的参数\ndef initialize(context):\n    # 从参数中获取值，如果没有则使用默认值\n    context.short_window = g.short_window if hasattr(g, 'short_window') else 5\n    context.long_window = g.long_window if hasattr(g, 'long_window') else 20\n    context.rsi_period = g.rsi_period if hasattr(g, 'rsi_period') else 14\n    \n    # 其他初始化代码...\n```\n\n使用API进行参数优化：\n\n```python\n# 参数优化示例\noptimization_config = {\n    \"strategy_id\": 1,\n    \"parameters\": {\n        \"short_window\": {\"min\": 3, \"max\": 10, \"step\": 1},\n        \"long_window\": {\"min\": 15, \"max\": 30, \"step\": 1},\n        \"rsi_period\": {\"min\": 10, \"max\": 20, \"step\": 2}\n    },\n    \"objective\": \"sharpe_ratio\",\n    \"method\": \"grid_search\"\n}\n\n# 提交优化任务\nresponse = requests.post(\n    \"/api/v1/strategies/1/optimize\",\n    json=optimization_config,\n    headers=auth_headers\n)\n```\n\n### 组合策略\n\n```python\ndef initialize(context):\n    \"\"\"多策略组合。\"\"\"\n    # 策略1：动量策略\n    context.momentum_stocks = ['000001.XSHE', '600000.XSHG']\n    context.momentum_weight = 0.5\n    \n    # 策略2：均值回归策略\n    context.mean_reversion_stocks = ['000002.XSHE', '600036.XSHG']\n    context.mean_reversion_weight = 0.3\n    \n    # 策略3：价值策略\n    context.value_stocks = ['601166.XSHG', '000858.XSHE']\n    context.value_weight = 0.2\n    \n    set_benchmark('000300.XSHG')\n    \n    # 每周调仓\n    run_weekly(rebalance, weekday=1)\n\ndef rebalance(context):\n    \"\"\"组合调仓。\"\"\"\n    # 动量策略逻辑\n    momentum_positions = run_momentum_strategy(context)\n    \n    # 均值回归策略逻辑\n    mean_reversion_positions = run_mean_reversion_strategy(context)\n    \n    # 价值策略逻辑\n    value_positions = run_value_strategy(context)\n    \n    # 合并持仓\n    all_positions = {}\n    \n    # 按权重分配\n    for stock, weight in momentum_positions.items():\n        all_positions[stock] = weight * context.momentum_weight\n    \n    for stock, weight in mean_reversion_positions.items():\n        if stock in all_positions:\n            all_positions[stock] += weight * context.mean_reversion_weight\n        else:\n            all_positions[stock] = weight * context.mean_reversion_weight\n    \n    for stock, weight in value_positions.items():\n        if stock in all_positions:\n            all_positions[stock] += weight * context.value_weight\n        else:\n            all_positions[stock] = weight * context.value_weight\n    \n    # 执行调仓\n    for stock, target_weight in all_positions.items():\n        order_target_percent(stock, target_weight)\n\ndef run_momentum_strategy(context):\n    \"\"\"动量策略。\"\"\"\n    positions = {}\n    # 动量策略逻辑...\n    return positions\n\ndef run_mean_reversion_strategy(context):\n    \"\"\"均值回归策略。\"\"\"\n    positions = {}\n    # 均值回归策略逻辑...\n    return positions\n\ndef run_value_strategy(context):\n    \"\"\"价值策略。\"\"\"\n    positions = {}\n    # 价值策略逻辑...\n    return positions\n```\n\n## 策略评估\n\n### 关键指标\n\n在策略开发过程中，需要关注以下关键指标：\n\n1. **收益指标**\n   - 总收益率\n   - 年化收益率\n   - 超额收益率（相对基准）\n\n2. **风险指标**\n   - 最大回撤\n   - 波动率\n   - VaR（风险价值）\n\n3. **风险调整收益指标**\n   - 夏普比率\n   - 索提诺比率\n   - 卡尔马比率\n\n4. **交易指标**\n   - 胜率\n   - 盈亏比\n   - 交易频率\n   - 换手率\n\n### 回测分析\n\n```python\n# 获取回测结果\nbacktest_result = get_backtest_result(backtest_id)\n\n# 分析收益分布\nreturns = backtest_result['daily_returns']\nprint(f\"平均日收益率: {returns.mean():.4f}\")\nprint(f\"收益率标准差: {returns.std():.4f}\")\nprint(f\"偏度: {returns.skew():.4f}\")\nprint(f\"峰度: {returns.kurtosis():.4f}\")\n\n# 分析回撤\ndrawdowns = backtest_result['drawdowns']\nprint(f\"最大回撤: {drawdowns.min():.2%}\")\nprint(f\"平均回撤: {drawdowns.mean():.2%}\")\n\n# 分析交易\ntrades = backtest_result['trades']\nwinning_trades = trades[trades['pnl'] > 0]\nlosing_trades = trades[trades['pnl'] < 0]\n\nwin_rate = len(winning_trades) / len(trades)\navg_win = winning_trades['pnl'].mean()\navg_loss = losing_trades['pnl'].mean()\nprofit_loss_ratio = abs(avg_win / avg_loss)\n\nprint(f\"胜率: {win_rate:.2%}\")\nprint(f\"盈亏比: {profit_loss_ratio:.2f}\")\n```\n\n## 常见问题和解决方案\n\n### 1. 数据问题\n\n**问题**: 获取不到某只股票的数据\n```python\n# 解决方案：添加数据检查\nhist = attribute_history(security, 20, '1d', ['close'])\nif hist.empty or len(hist) < 20:\n    log.warning(f\"股票 {security} 数据不足，跳过\")\n    return\n```\n\n### 2. 过拟合问题\n\n**问题**: 策略在历史数据上表现很好，但实盘效果差\n\n**解决方案**:\n- 使用样本外测试\n- 简化策略逻辑\n- 增加交易成本\n- 使用交叉验证\n\n### 3. 流动性问题\n\n**问题**: 策略买入的股票流动性不足\n\n```python\n# 解决方案：添加流动性过滤\ndef filter_by_liquidity(stocks, min_volume=1000000):\n    \"\"\"按流动性过滤股票。\"\"\"\n    filtered_stocks = []\n    for stock in stocks:\n        # 获取过去20天的平均成交量\n        hist = attribute_history(stock, 20, '1d', ['volume'])\n        if hist['volume'].mean() > min_volume:\n            filtered_stocks.append(stock)\n    return filtered_stocks\n```\n\n### 4. 资金容量问题\n\n**问题**: 策略在小资金时表现好，大资金时表现差\n\n**解决方案**:\n- 分散投资\n- 降低换手率\n- 考虑市场冲击成本\n\n## 最佳实践\n\n### 1. 策略开发流程\n\n1. **想法验证**: 先用简单的方法验证策略想法\n2. **原型开发**: 开发最小可行版本\n3. **回测验证**: 在历史数据上测试\n4. **样本外测试**: 在未见过的数据上测试\n5. **实盘验证**: 小资金实盘测试\n6. **规模化**: 逐步增加资金规模\n\n### 2. 代码规范\n\n```python\n# 好的实践\ndef initialize(context):\n    \"\"\"策略初始化。\n    \n    设置策略参数、股票池、基准等。\n    \"\"\"\n    # 使用有意义的变量名\n    context.momentum_window = 20\n    context.rebalance_frequency = 'monthly'\n    \n    # 添加注释说明\n    # 选择流动性好的大盘股\n    context.stock_pool = get_large_cap_stocks()\n    \n    # 设置合理的手续费\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,  # 印花税\n        open_commission=0.0003,  # 佣金\n        close_commission=0.0003,\n        min_commission=5  # 最小佣金\n    ), type='stock')\n\ndef handle_data(context, data):\n    \"\"\"数据处理函数。\n    \n    Args:\n        context: 策略上下文\n        data: 当日数据\n    \"\"\"\n    # 添加错误处理\n    try:\n        # 策略逻辑\n        execute_strategy_logic(context, data)\n    except Exception as e:\n        log.error(f\"策略执行出错: {e}\")\n        return\n\ndef execute_strategy_logic(context, data):\n    \"\"\"执行策略逻辑。\"\"\"\n    # 将复杂逻辑拆分为小函数\n    signals = generate_trading_signals(context, data)\n    execute_trades(context, signals)\n```\n\n### 3. 性能优化\n\n```python\n# 缓存计算结果\nif not hasattr(context, 'cached_data'):\n    context.cached_data = {}\n\n# 避免重复计算\nif 'ma20' not in context.cached_data:\n    hist = attribute_history(security, 20, '1d', ['close'])\n    context.cached_data['ma20'] = hist['close'].mean()\n\nma20 = context.cached_data['ma20']\n\n# 批量获取数据\nall_prices = history(20, '1d', 'close', context.stocks)\nfor stock in context.stocks:\n    ma20 = all_prices[stock].mean()\n    # 处理逻辑...\n```\n\n## 总结\n\n策略开发是一个迭代的过程，需要：\n\n1. **扎实的理论基础**: 了解金融市场和投资理论\n2. **编程技能**: 熟练使用Python和相关库\n3. **数据分析能力**: 能够处理和分析大量数据\n4. **风险意识**: 时刻关注风险控制\n5. **持续学习**: 跟上市场变化和技术发展\n\n记住，没有完美的策略，只有适合当前市场环境的策略。保持谦逊，持续改进，才能在量化投资的道路上走得更远。\n\n---\n\n*本教程持续更新中，欢迎提出改进建议。*