#!/usr/bin/env python3\n\"\"\"\n健康检查脚本\n用于检查应用程序的各个组件是否正常运行\n\"\"\"\n\nimport asyncio\nimport sys\nimport time\nfrom typing import Dict, List, Tuple\n\nimport aiohttp\nimport asyncpg\nimport redis.asyncio as redis\nfrom pydantic import BaseSettings\n\n\nclass HealthCheckSettings(BaseSettings):\n    \"\"\"健康检查配置\"\"\"\n    database_url: str = \"postgresql://postgres:password@localhost:5432/quant_framework\"\n    redis_url: str = \"redis://localhost:6379/0\"\n    api_url: str = \"http://localhost:8000\"\n    timeout: int = 30\n    \n    class Config:\n        env_file = \".env\"\n\n\nclass HealthChecker:\n    \"\"\"健康检查器\"\"\"\n    \n    def __init__(self, settings: HealthCheckSettings):\n        self.settings = settings\n        self.results: List[Tuple[str, bool, str]] = []\n    \n    async def check_database(self) -> Tuple[bool, str]:\n        \"\"\"检查数据库连接\"\"\"\n        try:\n            conn = await asyncpg.connect(self.settings.database_url)\n            await conn.execute(\"SELECT 1\")\n            await conn.close()\n            return True, \"Database connection successful\"\n        except Exception as e:\n            return False, f\"Database connection failed: {str(e)}\"\n    \n    async def check_redis(self) -> Tuple[bool, str]:\n        \"\"\"检查Redis连接\"\"\"\n        try:\n            r = redis.from_url(self.settings.redis_url)\n            await r.ping()\n            await r.close()\n            return True, \"Redis connection successful\"\n        except Exception as e:\n            return False, f\"Redis connection failed: {str(e)}\"\n    \n    async def check_api_health(self) -> Tuple[bool, str]:\n        \"\"\"检查API健康状态\"\"\"\n        try:\n            timeout = aiohttp.ClientTimeout(total=self.settings.timeout)\n            async with aiohttp.ClientSession(timeout=timeout) as session:\n                async with session.get(f\"{self.settings.api_url}/health\") as response:\n                    if response.status == 200:\n                        data = await response.json()\n                        return True, f\"API health check successful: {data.get('status', 'unknown')}\"\n                    else:\n                        return False, f\"API health check failed with status: {response.status}\"\n        except Exception as e:\n            return False, f\"API health check failed: {str(e)}\"\n    \n    async def check_api_ready(self) -> Tuple[bool, str]:\n        \"\"\"检查API就绪状态\"\"\"\n        try:\n            timeout = aiohttp.ClientTimeout(total=self.settings.timeout)\n            async with aiohttp.ClientSession(timeout=timeout) as session:\n                async with session.get(f\"{self.settings.api_url}/ready\") as response:\n                    if response.status == 200:\n                        data = await response.json()\n                        return True, f\"API ready check successful: {data.get('status', 'unknown')}\"\n                    else:\n                        return False, f\"API ready check failed with status: {response.status}\"\n        except Exception as e:\n            return False, f\"API ready check failed: {str(e)}\"\n    \n    async def check_celery_workers(self) -> Tuple[bool, str]:\n        \"\"\"检查Celery工作进程\"\"\"\n        try:\n            r = redis.from_url(self.settings.redis_url)\n            \n            # 检查活跃的工作进程\n            active_workers = await r.smembers(\"celery.workers\")\n            if active_workers:\n                worker_count = len(active_workers)\n                await r.close()\n                return True, f\"Found {worker_count} active Celery workers\"\n            else:\n                await r.close()\n                return False, \"No active Celery workers found\"\n        except Exception as e:\n            return False, f\"Celery worker check failed: {str(e)}\"\n    \n    async def run_all_checks(self) -> Dict[str, Tuple[bool, str]]:\n        \"\"\"运行所有健康检查\"\"\"\n        checks = {\n            \"database\": self.check_database(),\n            \"redis\": self.check_redis(),\n            \"api_health\": self.check_api_health(),\n            \"api_ready\": self.check_api_ready(),\n            \"celery_workers\": self.check_celery_workers(),\n        }\n        \n        results = {}\n        for name, check_coro in checks.items():\n            try:\n                success, message = await check_coro\n                results[name] = (success, message)\n            except Exception as e:\n                results[name] = (False, f\"Check failed with exception: {str(e)}\")\n        \n        return results\n    \n    def print_results(self, results: Dict[str, Tuple[bool, str]]) -> bool:\n        \"\"\"打印检查结果\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"HEALTH CHECK RESULTS\")\n        print(\"=\" * 60)\n        \n        all_passed = True\n        for name, (success, message) in results.items():\n            status = \"✅ PASS\" if success else \"❌ FAIL\"\n            print(f\"{name.upper():20} {status:10} {message}\")\n            if not success:\n                all_passed = False\n        \n        print(\"=\" * 60)\n        overall_status = \"✅ ALL CHECKS PASSED\" if all_passed else \"❌ SOME CHECKS FAILED\"\n        print(f\"OVERALL STATUS: {overall_status}\")\n        print(\"=\" * 60 + \"\\n\")\n        \n        return all_passed\n\n\nasync def main():\n    \"\"\"主函数\"\"\"\n    settings = HealthCheckSettings()\n    checker = HealthChecker(settings)\n    \n    print(f\"Starting health checks for: {settings.api_url}\")\n    print(f\"Timeout: {settings.timeout} seconds\")\n    \n    start_time = time.time()\n    results = await checker.run_all_checks()\n    end_time = time.time()\n    \n    all_passed = checker.print_results(results)\n    \n    print(f\"Health check completed in {end_time - start_time:.2f} seconds\")\n    \n    # 返回适当的退出码\n    sys.exit(0 if all_passed else 1)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n