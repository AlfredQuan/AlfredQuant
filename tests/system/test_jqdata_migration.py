"""
聚宽策略迁移验证测试\n验证聚宽策略能够无缝迁移到本框架\n\"\"\"\n\nimport asyncio\nimport pytest\nfrom datetime import datetime, date\nfrom typing import Dict, List, Any\nfrom unittest.mock import patch, MagicMock\n\nfrom quant_framework.jqdata.api import JQDataAPI\nfrom quant_framework.jqdata.context import JQCompatibleContext\nfrom quant_framework.jqdata.data import JQDataProvider\nfrom quant_framework.backtest.engine import BacktestEngine\nfrom quant_framework.core.database import get_async_session\nfrom quant_framework.services.strategy_service import StrategyService\nfrom quant_framework.monitoring.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass TestJQDataMigration:\n    \"\"\"聚宽策略迁移测试\"\"\"\n    \n    @pytest.fixture\n    def jq_api(self):\n        \"\"\"JQData API fixture\"\"\"\n        return JQDataAPI()\n    \n    @pytest.fixture\n    def jq_context(self):\n        \"\"\"JQ兼容上下文fixture\"\"\"\n        return JQCompatibleContext()\n    \n    @pytest.mark.asyncio\n    async def test_simple_buy_hold_strategy_migration(self, jq_api, jq_context):\n        \"\"\"测试简单买入持有策略迁移\"\"\"\n        logger.info(\"测试简单买入持有策略迁移\")\n        \n        # 原始聚宽策略代码\n        jq_strategy_code = \"\"\"\n# 聚宽买入持有策略\ndef initialize(context):\n    g.security = '000001.XSHE'\n    set_benchmark('000300.XSHG')\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n\ndef handle_data(context, data):\n    security = g.security\n    order_target_percent(security, 1.0)\n\"\"\"\n        \n        # 迁移后的策略代码（应该完全兼容）\n        migrated_strategy_code = \"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n    set_benchmark('000300.XSHG')\n    set_order_cost(OrderCost(\n        open_tax=0,\n        close_tax=0.001,\n        open_commission=0.0003,\n        close_commission=0.0003,\n        min_commission=5\n    ), type='stock')\n\ndef handle_data(context, data):\n    security = context.security\n    order_target_percent(security, 1.0)\n\"\"\"\n        \n        # 验证策略代码语法\n        try:\n            compile(migrated_strategy_code, '<strategy>', 'exec')\n            logger.info(\"策略代码编译成功\")\n        except SyntaxError as e:\n            pytest.fail(f\"策略代码编译失败: {e}\")\n        \n        # 模拟策略执行\n        namespace = {\n            'context': jq_context,\n            'set_benchmark': jq_api.set_benchmark,\n            'set_order_cost': jq_api.set_order_cost,\n            'order_target_percent': jq_api.order_target_percent,\n            'OrderCost': jq_api.OrderCost\n        }\n        \n        exec(migrated_strategy_code, namespace)\n        \n        # 执行初始化\n        if 'initialize' in namespace:\n            namespace['initialize'](jq_context)\n        \n        # 验证初始化结果\n        assert jq_context.security == '000001.XSHE'\n        assert jq_context.benchmark == '000300.XSHG'\n        \n        # 模拟数据处理\n        mock_data = {\n            '000001.XSHE': MagicMock(close=10.5, volume=1000000)\n        }\n        \n        if 'handle_data' in namespace:\n            namespace['handle_data'](jq_context, mock_data)\n        \n        logger.info(\"简单买入持有策略迁移测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_moving_average_strategy_migration(self, jq_api, jq_context):\n        \"\"\"测试移动平均策略迁移\"\"\"\n        logger.info(\"测试移动平均策略迁移\")\n        \n        # 聚宽移动平均策略\n        jq_ma_strategy = \"\"\"\ndef initialize(context):\n    g.security = '000001.XSHE'\n    g.short_window = 5\n    g.long_window = 20\n    set_benchmark('000300.XSHG')\n\ndef handle_data(context, data):\n    security = g.security\n    \n    # 获取历史数据\n    hist = attribute_history(security, g.long_window, '1d', ['close'])\n    \n    if len(hist) < g.long_window:\n        return\n    \n    # 计算移动平均\n    short_ma = hist['close'][-g.short_window:].mean()\n    long_ma = hist['close'].mean()\n    \n    # 获取当前持仓\n    current_position = context.portfolio.positions[security]\n    \n    # 交易逻辑\n    if short_ma > long_ma and current_position.total_amount == 0:\n        order_target_percent(security, 1.0)\n    elif short_ma < long_ma and current_position.total_amount > 0:\n        order_target_percent(security, 0)\n\"\"\"\n        \n        # 迁移后的策略（使用context替代g）\n        migrated_ma_strategy = \"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n    context.short_window = 5\n    context.long_window = 20\n    set_benchmark('000300.XSHG')\n\ndef handle_data(context, data):\n    security = context.security\n    \n    # 获取历史数据\n    hist = attribute_history(security, context.long_window, '1d', ['close'])\n    \n    if len(hist) < context.long_window:\n        return\n    \n    # 计算移动平均\n    short_ma = hist['close'][-context.short_window:].mean()\n    long_ma = hist['close'].mean()\n    \n    # 获取当前持仓\n    current_position = context.portfolio.positions[security]\n    \n    # 交易逻辑\n    if short_ma > long_ma and current_position.total_amount == 0:\n        order_target_percent(security, 1.0)\n    elif short_ma < long_ma and current_position.total_amount > 0:\n        order_target_percent(security, 0)\n\"\"\"\n        \n        # 模拟历史数据\n        mock_hist_data = {\n            'close': [10.0, 10.2, 10.1, 10.3, 10.5, 10.4, 10.6, 10.8, 10.7, 10.9,\n                     11.0, 11.2, 11.1, 11.3, 11.5, 11.4, 11.6, 11.8, 11.7, 11.9]\n        }\n        \n        # 模拟投资组合\n        mock_portfolio = MagicMock()\n        mock_position = MagicMock(total_amount=0)\n        mock_portfolio.positions = {'000001.XSHE': mock_position}\n        jq_context.portfolio = mock_portfolio\n        \n        # 设置命名空间\n        namespace = {\n            'context': jq_context,\n            'set_benchmark': jq_api.set_benchmark,\n            'attribute_history': lambda *args, **kwargs: mock_hist_data,\n            'order_target_percent': jq_api.order_target_percent\n        }\n        \n        exec(migrated_ma_strategy, namespace)\n        \n        # 执行初始化\n        if 'initialize' in namespace:\n            namespace['initialize'](jq_context)\n        \n        # 验证初始化\n        assert jq_context.security == '000001.XSHE'\n        assert jq_context.short_window == 5\n        assert jq_context.long_window == 20\n        \n        # 执行数据处理\n        mock_data = {\n            '000001.XSHE': MagicMock(close=12.0)\n        }\n        \n        if 'handle_data' in namespace:\n            namespace['handle_data'](jq_context, mock_data)\n        \n        logger.info(\"移动平均策略迁移测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_multi_stock_strategy_migration(self, jq_api, jq_context):\n        \"\"\"测试多股票策略迁移\"\"\"\n        logger.info(\"测试多股票策略迁移\")\n        \n        # 多股票轮动策略\n        multi_stock_strategy = \"\"\"\ndef initialize(context):\n    context.stocks = ['000001.XSHE', '000002.XSHE', '600000.XSHG', '600036.XSHG']\n    context.lookback = 20\n    context.top_n = 2\n    set_benchmark('000300.XSHG')\n    \n    # 每月调仓\n    run_monthly(rebalance, monthday=1)\n\ndef rebalance(context):\n    # 计算动量得分\n    scores = {}\n    \n    for stock in context.stocks:\n        hist = attribute_history(stock, context.lookback + 1, '1d', ['close'])\n        \n        if len(hist) < context.lookback + 1:\n            continue\n        \n        # 计算收益率\n        returns = hist['close'].pct_change().dropna()\n        momentum_score = returns.mean()\n        scores[stock] = momentum_score\n    \n    # 选择前N只股票\n    sorted_stocks = sorted(scores.items(), key=lambda x: x[1], reverse=True)\n    selected_stocks = [stock for stock, score in sorted_stocks[:context.top_n]]\n    \n    # 等权重分配\n    target_weight = 1.0 / len(selected_stocks) if selected_stocks else 0\n    \n    for stock in context.stocks:\n        if stock in selected_stocks:\n            order_target_percent(stock, target_weight)\n        else:\n            order_target_percent(stock, 0)\n\ndef handle_data(context, data):\n    # 在这个策略中，主要逻辑在rebalance函数中\n    pass\n\"\"\"\n        \n        # 模拟历史数据\n        def mock_attribute_history(security, count, unit, fields):\n            import pandas as pd\n            import numpy as np\n            \n            # 生成模拟价格数据\n            dates = pd.date_range(start='2024-01-01', periods=count, freq='D')\n            prices = 10 + np.cumsum(np.random.randn(count) * 0.02)\n            \n            return pd.DataFrame({\n                'close': prices\n            }, index=dates)\n        \n        # 设置命名空间\n        namespace = {\n            'context': jq_context,\n            'set_benchmark': jq_api.set_benchmark,\n            'run_monthly': jq_api.run_monthly,\n            'attribute_history': mock_attribute_history,\n            'order_target_percent': jq_api.order_target_percent\n        }\n        \n        exec(multi_stock_strategy, namespace)\n        \n        # 执行初始化\n        if 'initialize' in namespace:\n            namespace['initialize'](jq_context)\n        \n        # 验证初始化\n        assert len(jq_context.stocks) == 4\n        assert jq_context.lookback == 20\n        assert jq_context.top_n == 2\n        \n        # 执行调仓函数\n        if 'rebalance' in namespace:\n            namespace['rebalance'](jq_context)\n        \n        logger.info(\"多股票策略迁移测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_technical_indicator_strategy_migration(self, jq_api, jq_context):\n        \"\"\"测试技术指标策略迁移\"\"\"\n        logger.info(\"测试技术指标策略迁移\")\n        \n        # 技术指标策略\n        technical_strategy = \"\"\"\nimport talib\n\ndef initialize(context):\n    context.security = '000001.XSHE'\n    context.rsi_window = 14\n    context.rsi_overbought = 70\n    context.rsi_oversold = 30\n    set_benchmark('000300.XSHG')\n\ndef handle_data(context, data):\n    security = context.security\n    \n    # 获取历史数据\n    hist = attribute_history(security, 60, '1d', ['close', 'high', 'low'])\n    \n    if len(hist) < 60:\n        return\n    \n    # 计算RSI\n    rsi = talib.RSI(hist['close'].values, timeperiod=context.rsi_window)\n    current_rsi = rsi[-1]\n    \n    # 获取当前持仓\n    current_position = context.portfolio.positions[security]\n    \n    # 交易逻辑\n    if current_rsi < context.rsi_oversold and current_position.total_amount == 0:\n        order_target_percent(security, 1.0)\n    elif current_rsi > context.rsi_overbought and current_position.total_amount > 0:\n        order_target_percent(security, 0)\n\"\"\"\n        \n        # 模拟talib和历史数据\n        def mock_rsi(prices, timeperiod):\n            import numpy as np\n            # 简单模拟RSI计算\n            return np.random.uniform(20, 80, len(prices))\n        \n        def mock_attribute_history(security, count, unit, fields):\n            import pandas as pd\n            import numpy as np\n            \n            dates = pd.date_range(start='2024-01-01', periods=count, freq='D')\n            prices = 10 + np.cumsum(np.random.randn(count) * 0.02)\n            \n            return pd.DataFrame({\n                'close': prices,\n                'high': prices * 1.02,\n                'low': prices * 0.98\n            }, index=dates)\n        \n        # 模拟投资组合\n        mock_portfolio = MagicMock()\n        mock_position = MagicMock(total_amount=0)\n        mock_portfolio.positions = {'000001.XSHE': mock_position}\n        jq_context.portfolio = mock_portfolio\n        \n        # 设置命名空间\n        namespace = {\n            'context': jq_context,\n            'talib': MagicMock(RSI=mock_rsi),\n            'set_benchmark': jq_api.set_benchmark,\n            'attribute_history': mock_attribute_history,\n            'order_target_percent': jq_api.order_target_percent\n        }\n        \n        exec(technical_strategy, namespace)\n        \n        # 执行初始化\n        if 'initialize' in namespace:\n            namespace['initialize'](jq_context)\n        \n        # 验证初始化\n        assert jq_context.security == '000001.XSHE'\n        assert jq_context.rsi_window == 14\n        \n        # 执行数据处理\n        mock_data = {\n            '000001.XSHE': MagicMock(close=10.5)\n        }\n        \n        if 'handle_data' in namespace:\n            namespace['handle_data'](jq_context, mock_data)\n        \n        logger.info(\"技术指标策略迁移测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_fundamental_strategy_migration(self, jq_api, jq_context):\n        \"\"\"测试基本面策略迁移\"\"\"\n        logger.info(\"测试基本面策略迁移\")\n        \n        # 基本面策略\n        fundamental_strategy = \"\"\"\ndef initialize(context):\n    context.stocks = get_all_securities(['stock']).index.tolist()[:100]\n    context.max_positions = 10\n    set_benchmark('000300.XSHG')\n    \n    # 每月调仓\n    run_monthly(rebalance, monthday=1)\n\ndef rebalance(context):\n    # 获取基本面数据\n    q = query(\n        valuation.code,\n        valuation.pe_ratio,\n        valuation.pb_ratio,\n        income.net_profit\n    ).filter(\n        valuation.code.in_(context.stocks),\n        valuation.pe_ratio > 0,\n        valuation.pb_ratio > 0,\n        income.net_profit > 0\n    )\n    \n    df = get_fundamentals(q)\n    \n    if df.empty:\n        return\n    \n    # 计算综合得分\n    df['pe_score'] = 1 / df['pe_ratio']\n    df['pb_score'] = 1 / df['pb_ratio']\n    df['profit_score'] = df['net_profit'] / df['net_profit'].max()\n    \n    df['total_score'] = (\n        df['pe_score'] * 0.3 +\n        df['pb_score'] * 0.3 +\n        df['profit_score'] * 0.4\n    )\n    \n    # 选择得分最高的股票\n    df = df.sort_values('total_score', ascending=False)\n    selected_stocks = df.head(context.max_positions)['code'].tolist()\n    \n    # 等权重分配\n    target_weight = 1.0 / len(selected_stocks) if selected_stocks else 0\n    \n    for stock in context.stocks:\n        if stock in selected_stocks:\n            order_target_percent(stock, target_weight)\n        else:\n            order_target_percent(stock, 0)\n\ndef handle_data(context, data):\n    pass\n\"\"\"\n        \n        # 模拟基本面数据\n        def mock_get_all_securities(types):\n            import pandas as pd\n            stocks = [f'00000{i}.XSHE' for i in range(1, 101)]\n            return pd.DataFrame(index=stocks)\n        \n        def mock_get_fundamentals(query):\n            import pandas as pd\n            import numpy as np\n            \n            # 模拟基本面数据\n            data = {\n                'code': [f'00000{i}.XSHE' for i in range(1, 21)],\n                'pe_ratio': np.random.uniform(10, 50, 20),\n                'pb_ratio': np.random.uniform(1, 5, 20),\n                'net_profit': np.random.uniform(1e8, 1e10, 20)\n            }\n            \n            return pd.DataFrame(data)\n        \n        # 模拟查询对象\n        mock_query = MagicMock()\n        mock_valuation = MagicMock()\n        mock_income = MagicMock()\n        \n        # 设置命名空间\n        namespace = {\n            'context': jq_context,\n            'get_all_securities': mock_get_all_securities,\n            'set_benchmark': jq_api.set_benchmark,\n            'run_monthly': jq_api.run_monthly,\n            'query': lambda *args: mock_query,\n            'valuation': mock_valuation,\n            'income': mock_income,\n            'get_fundamentals': mock_get_fundamentals,\n            'order_target_percent': jq_api.order_target_percent\n        }\n        \n        exec(fundamental_strategy, namespace)\n        \n        # 执行初始化\n        if 'initialize' in namespace:\n            namespace['initialize'](jq_context)\n        \n        # 验证初始化\n        assert len(jq_context.stocks) == 100\n        assert jq_context.max_positions == 10\n        \n        # 执行调仓\n        if 'rebalance' in namespace:\n            namespace['rebalance'](jq_context)\n        \n        logger.info(\"基本面策略迁移测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_complete_strategy_migration_workflow(self):\n        \"\"\"测试完整的策略迁移工作流\"\"\"\n        logger.info(\"测试完整的策略迁移工作流\")\n        \n        # 1. 原始聚宽策略\n        original_jq_strategy = \"\"\"\n# 聚宽双均线策略\ndef initialize(context):\n    g.security = '000001.XSHE'\n    g.short_window = 5\n    g.long_window = 20\n    set_benchmark('000300.XSHG')\n    \ndef handle_data(context, data):\n    security = g.security\n    hist = attribute_history(security, g.long_window, '1d', ['close'])\n    \n    if len(hist) < g.long_window:\n        return\n    \n    short_ma = hist['close'][-g.short_window:].mean()\n    long_ma = hist['close'].mean()\n    \n    current_position = context.portfolio.positions[security]\n    \n    if short_ma > long_ma and current_position.total_amount == 0:\n        order_target_percent(security, 1.0)\n    elif short_ma < long_ma and current_position.total_amount > 0:\n        order_target_percent(security, 0)\n\"\"\"\n        \n        # 2. 迁移策略（替换g为context）\n        migrated_strategy = original_jq_strategy.replace('g.', 'context.')\n        \n        # 3. 在系统中创建策略\n        async with get_async_session() as session:\n            strategy_service = StrategyService(session)\n            \n            strategy_data = {\n                'name': '迁移测试双均线策略',\n                'description': '从聚宽迁移的双均线策略',\n                'code': migrated_strategy,\n                'parameters': {\n                    'short_window': 5,\n                    'long_window': 20,\n                    'initial_capital': 1000000\n                }\n            }\n            \n            # 创建策略\n            strategy = await strategy_service.create_strategy(strategy_data, user_id=1)\n            assert strategy is not None\n            \n            # 4. 验证策略代码\n            validation_result = await strategy_service.validate_strategy_code(strategy.code)\n            assert validation_result['is_valid'] is True\n            \n            # 5. 模拟回测执行\n            # 这里简化处理，实际会通过回测引擎执行\n            \n            logger.info(f\"策略迁移成功，策略ID: {strategy.id}\")\n        \n        logger.info(\"完整策略迁移工作流测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_migration_compatibility_matrix(self):\n        \"\"\"测试迁移兼容性矩阵\"\"\"\n        logger.info(\"测试迁移兼容性矩阵\")\n        \n        # 兼容性测试用例\n        compatibility_tests = [\n            {\n                'name': 'g变量替换',\n                'original': 'g.security = \"000001.XSHE\"',\n                'migrated': 'context.security = \"000001.XSHE\"',\n                'compatible': True\n            },\n            {\n                'name': '函数调用',\n                'original': 'order_target_percent(g.security, 1.0)',\n                'migrated': 'order_target_percent(context.security, 1.0)',\n                'compatible': True\n            },\n            {\n                'name': '数据获取',\n                'original': 'attribute_history(security, 20, \"1d\", [\"close\"])',\n                'migrated': 'attribute_history(security, 20, \"1d\", [\"close\"])',\n                'compatible': True\n            },\n            {\n                'name': '基准设置',\n                'original': 'set_benchmark(\"000300.XSHG\")',\n                'migrated': 'set_benchmark(\"000300.XSHG\")',\n                'compatible': True\n            },\n            {\n                'name': '定时任务',\n                'original': 'run_monthly(rebalance, monthday=1)',\n                'migrated': 'run_monthly(rebalance, monthday=1)',\n                'compatible': True\n            }\n        ]\n        \n        passed_tests = 0\n        total_tests = len(compatibility_tests)\n        \n        for test in compatibility_tests:\n            try:\n                # 验证迁移后的代码语法\n                compile(test['migrated'], '<test>', 'exec')\n                \n                if test['compatible']:\n                    passed_tests += 1\n                    logger.info(f\"✓ {test['name']}: 兼容\")\n                else:\n                    logger.warning(f\"⚠ {test['name']}: 不兼容但语法正确\")\n                    \n            except SyntaxError:\n                if not test['compatible']:\n                    passed_tests += 1\n                    logger.info(f\"✓ {test['name']}: 预期不兼容\")\n                else:\n                    logger.error(f\"✗ {test['name']}: 语法错误\")\n        \n        compatibility_rate = passed_tests / total_tests * 100\n        logger.info(f\"兼容性测试通过率: {compatibility_rate:.1f}%\")\n        \n        # 要求兼容性达到90%以上\n        assert compatibility_rate >= 90\n        \n        logger.info(\"迁移兼容性矩阵测试通过\")\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"--tb=short\"])\n