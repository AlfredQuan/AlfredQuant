"""
压力测试\n测试系统在高负载下的性能和稳定性\n\"\"\"\n\nimport asyncio\nimport pytest\nimport time\nimport random\nfrom datetime import datetime, date, timedelta\nfrom typing import List, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport psutil\nimport threading\nfrom unittest.mock import patch, MagicMock\n\nfrom quant_framework.core.database import get_async_session\nfrom quant_framework.services.strategy_service import StrategyService\nfrom quant_framework.services.backtest_service import BacktestService\nfrom quant_framework.services.data_service import DataService\nfrom quant_framework.performance.cache import cache_manager\nfrom quant_framework.performance.data_loader import async_data_loader\nfrom quant_framework.performance.metrics import performance_metrics\nfrom quant_framework.monitoring.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass TestStressTesting:\n    \"\"\"压力测试套件\"\"\"\n    \n    @pytest.fixture(autouse=True)\n    async def setup_stress_test(self):\n        \"\"\"设置压力测试环境\"\"\"\n        # 启动所有服务\n        performance_metrics.start()\n        await async_data_loader.start()\n        \n        # 记录初始资源使用\n        self.initial_memory = psutil.Process().memory_info().rss / 1024 / 1024\n        self.initial_cpu = psutil.cpu_percent()\n        \n        logger.info(f\"压力测试开始 - 初始内存: {self.initial_memory:.1f}MB, CPU: {self.initial_cpu:.1f}%\")\n        \n        yield\n        \n        # 清理和报告\n        final_memory = psutil.Process().memory_info().rss / 1024 / 1024\n        final_cpu = psutil.cpu_percent()\n        \n        logger.info(f\"压力测试结束 - 最终内存: {final_memory:.1f}MB, CPU: {final_cpu:.1f}%\")\n        logger.info(f\"内存增长: {final_memory - self.initial_memory:.1f}MB\")\n        \n        await performance_metrics.stop()\n        await async_data_loader.stop()\n        await cache_manager.close()\n    \n    @pytest.mark.stress\n    @pytest.mark.asyncio\n    async def test_concurrent_strategy_creation_stress(self):\n        \"\"\"并发策略创建压力测试\"\"\"\n        logger.info(\"开始并发策略创建压力测试\")\n        \n        concurrent_users = 50\n        strategies_per_user = 10\n        \n        async def create_strategies_for_user(user_id: int):\n            \"\"\"为单个用户创建策略\"\"\"\n            created_strategies = []\n            \n            async with get_async_session() as session:\n                strategy_service = StrategyService(session)\n                \n                for i in range(strategies_per_user):\n                    try:\n                        strategy_data = {\n                            'name': f'压力测试策略_用户{user_id}_策略{i}',\n                            'description': f'用户{user_id}的第{i}个压力测试策略',\n                            'code': f\"\"\"\ndef initialize(context):\n    context.security = '00000{random.randint(1, 9)}.XSHE'\n    context.user_id = {user_id}\n    context.strategy_index = {i}\n    \ndef handle_data(context, data):\n    # 简单的买入持有逻辑\n    order_target_percent(context.security, 1.0)\n\"\"\",\n                            'parameters': {\n                                'user_id': user_id,\n                                'strategy_index': i,\n                                'created_at': datetime.now().isoformat()\n                            }\n                        }\n                        \n                        strategy = await strategy_service.create_strategy(strategy_data, user_id=user_id)\n                        created_strategies.append(strategy)\n                        \n                        # 随机延迟模拟真实用户行为\n                        await asyncio.sleep(random.uniform(0.01, 0.1))\n                        \n                    except Exception as e:\n                        logger.error(f\"用户{user_id}创建策略{i}失败: {e}\")\n            \n            return created_strategies\n        \n        # 记录开始时间\n        start_time = time.time()\n        \n        # 并发执行\n        tasks = [create_strategies_for_user(user_id) for user_id in range(1, concurrent_users + 1)]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 统计结果\n        total_time = time.time() - start_time\n        successful_results = [r for r in results if not isinstance(r, Exception)]\n        total_strategies = sum(len(strategies) for strategies in successful_results)\n        \n        logger.info(f\"并发策略创建完成:\")\n        logger.info(f\"  - 总耗时: {total_time:.2f}秒\")\n        logger.info(f\"  - 成功用户: {len(successful_results)}/{concurrent_users}\")\n        logger.info(f\"  - 创建策略总数: {total_strategies}\")\n        logger.info(f\"  - 平均创建速度: {total_strategies/total_time:.1f}策略/秒\")\n        \n        # 性能断言\n        assert len(successful_results) >= concurrent_users * 0.9  # 90%成功率\n        assert total_strategies >= concurrent_users * strategies_per_user * 0.8  # 80%策略创建成功\n        assert total_time < 60  # 总时间不超过60秒\n    \n    @pytest.mark.stress\n    @pytest.mark.asyncio\n    async def test_high_frequency_data_access_stress(self):\n        \"\"\"高频数据访问压力测试\"\"\"\n        logger.info(\"开始高频数据访问压力测试\")\n        \n        concurrent_requests = 100\n        requests_per_client = 50\n        \n        # 模拟数据\n        test_symbols = [f'00000{i}.XSHE' for i in range(1, 21)]\n        \n        async def high_frequency_data_client(client_id: int):\n            \"\"\"高频数据访问客户端\"\"\"\n            successful_requests = 0\n            failed_requests = 0\n            \n            async with get_async_session() as session:\n                data_service = DataService(session)\n                \n                for i in range(requests_per_client):\n                    try:\n                        # 随机选择股票和日期范围\n                        symbol = random.choice(test_symbols)\n                        days_back = random.randint(1, 30)\n                        end_date = date.today()\n                        start_date = end_date - timedelta(days=days_back)\n                        \n                        # 获取价格数据\n                        price_data = await data_service.get_price_data(\n                            symbol=symbol,\n                            start_date=start_date,\n                            end_date=end_date\n                        )\n                        \n                        successful_requests += 1\n                        \n                        # 短暂延迟模拟处理时间\n                        await asyncio.sleep(0.001)\n                        \n                    except Exception as e:\n                        failed_requests += 1\n                        logger.debug(f\"客户端{client_id}请求{i}失败: {e}\")\n            \n            return {\n                'client_id': client_id,\n                'successful': successful_requests,\n                'failed': failed_requests\n            }\n        \n        # 记录开始时间和资源使用\n        start_time = time.time()\n        start_memory = psutil.Process().memory_info().rss / 1024 / 1024\n        \n        # 并发执行\n        tasks = [high_frequency_data_client(i) for i in range(concurrent_requests)]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 统计结果\n        total_time = time.time() - start_time\n        end_memory = psutil.Process().memory_info().rss / 1024 / 1024\n        \n        successful_results = [r for r in results if not isinstance(r, Exception)]\n        total_successful = sum(r['successful'] for r in successful_results)\n        total_failed = sum(r['failed'] for r in successful_results)\n        total_requests = total_successful + total_failed\n        \n        logger.info(f\"高频数据访问压力测试完成:\")\n        logger.info(f\"  - 总耗时: {total_time:.2f}秒\")\n        logger.info(f\"  - 总请求数: {total_requests}\")\n        logger.info(f\"  - 成功请求: {total_successful}\")\n        logger.info(f\"  - 失败请求: {total_failed}\")\n        logger.info(f\"  - 成功率: {total_successful/total_requests*100:.1f}%\")\n        logger.info(f\"  - 请求速度: {total_requests/total_time:.1f}请求/秒\")\n        logger.info(f\"  - 内存增长: {end_memory - start_memory:.1f}MB\")\n        \n        # 性能断言\n        success_rate = total_successful / total_requests if total_requests > 0 else 0\n        assert success_rate >= 0.95  # 95%成功率\n        assert total_requests / total_time >= 100  # 至少100请求/秒\n        assert end_memory - start_memory < 100  # 内存增长不超过100MB\n    \n    @pytest.mark.stress\n    @pytest.mark.asyncio\n    async def test_cache_performance_stress(self):\n        \"\"\"缓存性能压力测试\"\"\"\n        logger.info(\"开始缓存性能压力测试\")\n        \n        concurrent_operations = 200\n        operations_per_client = 100\n        \n        async def cache_stress_client(client_id: int):\n            \"\"\"缓存压力测试客户端\"\"\"\n            operations = {\n                'set': 0,\n                'get': 0,\n                'hit': 0,\n                'miss': 0,\n                'delete': 0\n            }\n            \n            for i in range(operations_per_client):\n                try:\n                    key = f\"stress_test_{client_id}_{i}\"\n                    value = {\n                        'client_id': client_id,\n                        'operation': i,\n                        'timestamp': time.time(),\n                        'data': list(range(100))  # 一些测试数据\n                    }\n                    \n                    # 随机选择操作类型\n                    operation = random.choices(\n                        ['set', 'get', 'delete'],\n                        weights=[0.4, 0.5, 0.1],  # 40%写入，50%读取，10%删除\n                        k=1\n                    )[0]\n                    \n                    if operation == 'set':\n                        await cache_manager.set(key, value, ttl=300)\n                        operations['set'] += 1\n                        \n                    elif operation == 'get':\n                        result = await cache_manager.get(key)\n                        operations['get'] += 1\n                        \n                        if result is not None:\n                            operations['hit'] += 1\n                        else:\n                            operations['miss'] += 1\n                            \n                    elif operation == 'delete':\n                        await cache_manager.delete(key)\n                        operations['delete'] += 1\n                    \n                    # 短暂延迟\n                    await asyncio.sleep(0.001)\n                    \n                except Exception as e:\n                    logger.debug(f\"缓存客户端{client_id}操作失败: {e}\")\n            \n            return operations\n        \n        # 记录开始时间\n        start_time = time.time()\n        \n        # 并发执行\n        tasks = [cache_stress_client(i) for i in range(concurrent_operations)]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 统计结果\n        total_time = time.time() - start_time\n        successful_results = [r for r in results if not isinstance(r, Exception)]\n        \n        total_operations = {\n            'set': sum(r['set'] for r in successful_results),\n            'get': sum(r['get'] for r in successful_results),\n            'hit': sum(r['hit'] for r in successful_results),\n            'miss': sum(r['miss'] for r in successful_results),\n            'delete': sum(r['delete'] for r in successful_results)\n        }\n        \n        total_ops = sum(total_operations.values())\n        hit_rate = total_operations['hit'] / total_operations['get'] if total_operations['get'] > 0 else 0\n        \n        logger.info(f\"缓存压力测试完成:\")\n        logger.info(f\"  - 总耗时: {total_time:.2f}秒\")\n        logger.info(f\"  - 总操作数: {total_ops}\")\n        logger.info(f\"  - 设置操作: {total_operations['set']}\")\n        logger.info(f\"  - 获取操作: {total_operations['get']}\")\n        logger.info(f\"  - 缓存命中: {total_operations['hit']}\")\n        logger.info(f\"  - 缓存未命中: {total_operations['miss']}\")\n        logger.info(f\"  - 删除操作: {total_operations['delete']}\")\n        logger.info(f\"  - 命中率: {hit_rate*100:.1f}%\")\n        logger.info(f\"  - 操作速度: {total_ops/total_time:.1f}操作/秒\")\n        \n        # 获取缓存统计\n        cache_stats = await cache_manager.get_stats()\n        logger.info(f\"  - 缓存统计: {cache_stats}\")\n        \n        # 性能断言\n        assert total_ops / total_time >= 1000  # 至少1000操作/秒\n        assert len(successful_results) >= concurrent_operations * 0.95  # 95%客户端成功\n    \n    @pytest.mark.stress\n    @pytest.mark.asyncio\n    async def test_backtest_queue_stress(self):\n        \"\"\"回测队列压力测试\"\"\"\n        logger.info(\"开始回测队列压力测试\")\n        \n        concurrent_backtests = 20\n        \n        async def create_backtest_job(job_id: int):\n            \"\"\"创建回测任务\"\"\"\n            async with get_async_session() as session:\n                try:\n                    # 首先创建策略\n                    strategy_service = StrategyService(session)\n                    strategy_data = {\n                        'name': f'回测压力测试策略_{job_id}',\n                        'description': f'用于回测压力测试的策略 {job_id}',\n                        'code': f\"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n    context.job_id = {job_id}\n    \ndef handle_data(context, data):\n    # 简单逻辑\n    if context.job_id % 2 == 0:\n        order_target_percent(context.security, 1.0)\n    else:\n        order_target_percent(context.security, 0.5)\n\"\"\",\n                        'parameters': {'job_id': job_id}\n                    }\n                    \n                    strategy = await strategy_service.create_strategy(strategy_data, user_id=1)\n                    \n                    # 创建回测\n                    backtest_service = BacktestService(session)\n                    backtest_data = {\n                        'strategy_id': strategy.id,\n                        'name': f'压力测试回测_{job_id}',\n                        'start_date': date(2024, 1, 1),\n                        'end_date': date(2024, 3, 31),\n                        'initial_capital': 1000000\n                    }\n                    \n                    backtest = await backtest_service.create_backtest(backtest_data)\n                    \n                    # 模拟回测执行时间\n                    execution_time = random.uniform(1, 5)\n                    await asyncio.sleep(execution_time)\n                    \n                    # 模拟回测完成\n                    mock_results = {\n                        'total_return': random.uniform(-0.2, 0.3),\n                        'max_drawdown': random.uniform(0.05, 0.15),\n                        'sharpe_ratio': random.uniform(0.5, 2.0),\n                        'execution_time': execution_time\n                    }\n                    \n                    await backtest_service.save_backtest_results(backtest.id, mock_results)\n                    await backtest_service.update_backtest_status(backtest.id, 'completed')\n                    \n                    return {\n                        'job_id': job_id,\n                        'strategy_id': strategy.id,\n                        'backtest_id': backtest.id,\n                        'execution_time': execution_time,\n                        'status': 'completed'\n                    }\n                    \n                except Exception as e:\n                    logger.error(f\"回测任务{job_id}失败: {e}\")\n                    return {\n                        'job_id': job_id,\n                        'status': 'failed',\n                        'error': str(e)\n                    }\n        \n        # 记录开始时间\n        start_time = time.time()\n        \n        # 并发执行回测\n        tasks = [create_backtest_job(i) for i in range(concurrent_backtests)]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 统计结果\n        total_time = time.time() - start_time\n        successful_results = [r for r in results if not isinstance(r, Exception) and r.get('status') == 'completed']\n        failed_results = [r for r in results if isinstance(r, Exception) or r.get('status') == 'failed']\n        \n        avg_execution_time = sum(r['execution_time'] for r in successful_results) / len(successful_results) if successful_results else 0\n        \n        logger.info(f\"回测队列压力测试完成:\")\n        logger.info(f\"  - 总耗时: {total_time:.2f}秒\")\n        logger.info(f\"  - 成功回测: {len(successful_results)}\")\n        logger.info(f\"  - 失败回测: {len(failed_results)}\")\n        logger.info(f\"  - 成功率: {len(successful_results)/concurrent_backtests*100:.1f}%\")\n        logger.info(f\"  - 平均执行时间: {avg_execution_time:.2f}秒\")\n        \n        # 性能断言\n        success_rate = len(successful_results) / concurrent_backtests\n        assert success_rate >= 0.8  # 80%成功率\n        assert total_time < 300  # 总时间不超过5分钟\n    \n    @pytest.mark.stress\n    def test_memory_leak_stress(self):\n        \"\"\"内存泄漏压力测试\"\"\"\n        logger.info(\"开始内存泄漏压力测试\")\n        \n        import gc\n        \n        # 记录初始内存\n        gc.collect()\n        initial_memory = psutil.Process().memory_info().rss / 1024 / 1024\n        \n        # 执行大量操作\n        iterations = 1000\n        memory_samples = []\n        \n        for i in range(iterations):\n            # 创建大量对象\n            data_structures = []\n            \n            for j in range(100):\n                data_structures.append({\n                    'id': f'{i}_{j}',\n                    'data': list(range(100)),\n                    'metadata': {\n                        'created': time.time(),\n                        'iteration': i,\n                        'index': j\n                    }\n                })\n            \n            # 模拟处理\n            processed_data = []\n            for item in data_structures:\n                processed_item = {\n                    'processed_id': item['id'],\n                    'sum': sum(item['data']),\n                    'count': len(item['data'])\n                }\n                processed_data.append(processed_item)\n            \n            # 清理\n            del data_structures\n            del processed_data\n            \n            # 每100次迭代记录内存使用\n            if i % 100 == 0:\n                gc.collect()\n                current_memory = psutil.Process().memory_info().rss / 1024 / 1024\n                memory_samples.append(current_memory)\n                logger.debug(f\"迭代 {i}: 内存使用 {current_memory:.1f}MB\")\n        \n        # 最终内存检查\n        gc.collect()\n        final_memory = psutil.Process().memory_info().rss / 1024 / 1024\n        \n        memory_growth = final_memory - initial_memory\n        max_memory = max(memory_samples) if memory_samples else final_memory\n        \n        logger.info(f\"内存泄漏压力测试完成:\")\n        logger.info(f\"  - 初始内存: {initial_memory:.1f}MB\")\n        logger.info(f\"  - 最终内存: {final_memory:.1f}MB\")\n        logger.info(f\"  - 峰值内存: {max_memory:.1f}MB\")\n        logger.info(f\"  - 内存增长: {memory_growth:.1f}MB\")\n        logger.info(f\"  - 执行迭代: {iterations}\")\n        \n        # 内存泄漏检查\n        # 允许一定的内存增长，但不应该过多\n        assert memory_growth < 50  # 内存增长不超过50MB\n        assert max_memory - initial_memory < 100  # 峰值内存增长不超过100MB\n    \n    @pytest.mark.stress\n    @pytest.mark.asyncio\n    async def test_database_connection_stress(self):\n        \"\"\"数据库连接压力测试\"\"\"\n        logger.info(\"开始数据库连接压力测试\")\n        \n        concurrent_connections = 50\n        queries_per_connection = 20\n        \n        async def database_stress_client(client_id: int):\n            \"\"\"数据库压力测试客户端\"\"\"\n            successful_queries = 0\n            failed_queries = 0\n            \n            try:\n                async with get_async_session() as session:\n                    for i in range(queries_per_connection):\n                        try:\n                            # 执行简单查询\n                            result = await session.execute(\n                                \"SELECT 1 as test_value, :client_id as client_id, :query_id as query_id\",\n                                {'client_id': client_id, 'query_id': i}\n                            )\n                            row = result.fetchone()\n                            \n                            if row and row[0] == 1:\n                                successful_queries += 1\n                            else:\n                                failed_queries += 1\n                            \n                            # 短暂延迟\n                            await asyncio.sleep(0.01)\n                            \n                        except Exception as e:\n                            failed_queries += 1\n                            logger.debug(f\"客户端{client_id}查询{i}失败: {e}\")\n                            \n            except Exception as e:\n                logger.error(f\"客户端{client_id}连接失败: {e}\")\n                failed_queries = queries_per_connection\n            \n            return {\n                'client_id': client_id,\n                'successful': successful_queries,\n                'failed': failed_queries\n            }\n        \n        # 记录开始时间\n        start_time = time.time()\n        \n        # 并发执行\n        tasks = [database_stress_client(i) for i in range(concurrent_connections)]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 统计结果\n        total_time = time.time() - start_time\n        successful_results = [r for r in results if not isinstance(r, Exception)]\n        \n        total_successful = sum(r['successful'] for r in successful_results)\n        total_failed = sum(r['failed'] for r in successful_results)\n        total_queries = total_successful + total_failed\n        \n        logger.info(f\"数据库连接压力测试完成:\")\n        logger.info(f\"  - 总耗时: {total_time:.2f}秒\")\n        logger.info(f\"  - 并发连接: {concurrent_connections}\")\n        logger.info(f\"  - 总查询数: {total_queries}\")\n        logger.info(f\"  - 成功查询: {total_successful}\")\n        logger.info(f\"  - 失败查询: {total_failed}\")\n        logger.info(f\"  - 成功率: {total_successful/total_queries*100:.1f}%\")\n        logger.info(f\"  - 查询速度: {total_queries/total_time:.1f}查询/秒\")\n        \n        # 性能断言\n        success_rate = total_successful / total_queries if total_queries > 0 else 0\n        assert success_rate >= 0.95  # 95%成功率\n        assert len(successful_results) >= concurrent_connections * 0.9  # 90%连接成功\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"-m\", \"stress\", \"--tb=short\"])\n