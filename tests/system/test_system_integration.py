"""
系统集成测试
验证所有模块的集成和协同工作
\"\"\"\n\nimport asyncio\nimport pytest\nimport time\nfrom datetime import datetime, date, timedelta\nfrom typing import Dict, List, Any\nfrom unittest.mock import patch, MagicMock\n\nfrom quant_framework.core.database import get_async_session\nfrom quant_framework.data.models import Security, PriceData, Strategy, Backtest\nfrom quant_framework.services.strategy_service import StrategyService\nfrom quant_framework.services.backtest_service import BacktestService\nfrom quant_framework.services.data_service import DataService\nfrom quant_framework.services.trading_service import TradingService\nfrom quant_framework.jqdata.api import JQDataAPI\nfrom quant_framework.performance.cache import cache_manager\nfrom quant_framework.performance.data_loader import async_data_loader\nfrom quant_framework.performance.metrics import performance_metrics\nfrom quant_framework.monitoring.logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass TestSystemIntegration:\n    \"\"\"系统集成测试\"\"\"\n    \n    @pytest.fixture(autouse=True)\n    async def setup_system(self):\n        \"\"\"设置系统环境\"\"\"\n        # 启动性能监控\n        performance_metrics.start()\n        await async_data_loader.start()\n        \n        yield\n        \n        # 清理\n        await performance_metrics.stop()\n        await async_data_loader.stop()\n        await cache_manager.close()\n    \n    @pytest.mark.asyncio\n    async def test_complete_strategy_lifecycle(self):\n        \"\"\"测试完整的策略生命周期\"\"\"\n        logger.info(\"开始完整策略生命周期测试\")\n        \n        async with get_async_session() as session:\n            # 1. 创建策略服务\n            strategy_service = StrategyService(session)\n            backtest_service = BacktestService(session)\n            \n            # 2. 创建测试策略\n            strategy_code = \"\"\"\ndef initialize(context):\n    context.security = '000001.XSHE'\n    context.window = 20\n    set_benchmark('000300.XSHG')\n    \ndef handle_data(context, data):\n    security = context.security\n    hist = attribute_history(security, context.window, '1d', ['close'])\n    \n    if len(hist) < context.window:\n        return\n    \n    ma = hist['close'].mean()\n    current_price = data[security].close\n    \n    if current_price > ma * 1.02:\n        order_target_percent(security, 1.0)\n    elif current_price < ma * 0.98:\n        order_target_percent(security, 0)\n\"\"\"\n            \n            strategy_data = {\n                'name': '系统集成测试策略',\n                'description': '用于系统集成测试的移动平均策略',\n                'code': strategy_code,\n                'parameters': {\n                    'window': 20,\n                    'initial_capital': 1000000\n                }\n            }\n            \n            # 创建策略\n            strategy = await strategy_service.create_strategy(strategy_data, user_id=1)\n            assert strategy is not None\n            assert strategy.name == '系统集成测试策略'\n            \n            logger.info(f\"策略创建成功，ID: {strategy.id}\")\n            \n            # 3. 验证策略代码\n            validation_result = await strategy_service.validate_strategy_code(strategy.code)\n            assert validation_result['is_valid'] is True\n            \n            # 4. 创建回测\n            backtest_data = {\n                'strategy_id': strategy.id,\n                'name': '系统集成回测',\n                'start_date': date(2024, 1, 1),\n                'end_date': date(2024, 6, 30),\n                'initial_capital': 1000000,\n                'benchmark': '000300.XSHG'\n            }\n            \n            backtest = await backtest_service.create_backtest(backtest_data)\n            assert backtest is not None\n            \n            logger.info(f\"回测创建成功，ID: {backtest.id}\")\n            \n            # 5. 模拟回测执行（简化版）\n            # 在实际环境中，这会是异步任务\n            await backtest_service.update_backtest_status(backtest.id, 'running')\n            \n            # 模拟回测结果\n            mock_results = {\n                'total_return': 0.15,\n                'annual_return': 0.30,\n                'max_drawdown': 0.08,\n                'sharpe_ratio': 1.25,\n                'win_rate': 0.65,\n                'total_trades': 45\n            }\n            \n            await backtest_service.save_backtest_results(backtest.id, mock_results)\n            await backtest_service.update_backtest_status(backtest.id, 'completed')\n            \n            # 6. 验证结果\n            completed_backtest = await backtest_service.get_backtest(backtest.id)\n            assert completed_backtest.status == 'completed'\n            assert completed_backtest.results is not None\n            \n            logger.info(\"完整策略生命周期测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_data_pipeline_integration(self):\n        \"\"\"测试数据管道集成\"\"\"\n        logger.info(\"开始数据管道集成测试\")\n        \n        async with get_async_session() as session:\n            data_service = DataService(session)\n            \n            # 1. 测试证券数据获取\n            securities = await data_service.get_securities(\n                exchange='SZSE',\n                limit=10\n            )\n            assert len(securities) > 0\n            \n            # 2. 测试价格数据获取\n            test_symbol = securities[0].symbol\n            start_date = date(2024, 1, 1)\n            end_date = date(2024, 1, 31)\n            \n            price_data = await data_service.get_price_data(\n                symbol=test_symbol,\n                start_date=start_date,\n                end_date=end_date\n            )\n            \n            # 验证数据质量\n            if price_data:\n                assert all(p.date >= start_date for p in price_data)\n                assert all(p.date <= end_date for p in price_data)\n                assert all(p.close > 0 for p in price_data)\n            \n            # 3. 测试缓存集成\n            cache_key = f\"price_data:{test_symbol}:{start_date}:{end_date}\"\n            cached_data = await cache_manager.get(cache_key)\n            \n            # 第二次获取应该从缓存返回\n            start_time = time.time()\n            price_data_cached = await data_service.get_price_data(\n                symbol=test_symbol,\n                start_date=start_date,\n                end_date=end_date\n            )\n            cache_time = time.time() - start_time\n            \n            # 缓存访问应该很快\n            assert cache_time < 0.1\n            \n            logger.info(\"数据管道集成测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_jqdata_compatibility_integration(self):\n        \"\"\"测试聚宽兼容性集成\"\"\"\n        logger.info(\"开始聚宽兼容性集成测试\")\n        \n        # 创建JQData API实例\n        jq_api = JQDataAPI()\n        \n        # 测试聚宽兼容函数\n        with patch('quant_framework.jqdata.api.get_price') as mock_get_price:\n            # 模拟get_price返回数据\n            mock_data = {\n                'open': [10.0, 10.5, 11.0],\n                'high': [10.5, 11.0, 11.5],\n                'low': [9.8, 10.2, 10.8],\n                'close': [10.2, 10.8, 11.2],\n                'volume': [1000000, 1200000, 1100000]\n            }\n            mock_get_price.return_value = mock_data\n            \n            # 测试get_price函数\n            result = await jq_api.get_price(\n                security='000001.XSHE',\n                start_date='2024-01-01',\n                end_date='2024-01-03'\n            )\n            \n            assert result is not None\n            assert 'close' in result\n            assert len(result['close']) == 3\n        \n        # 测试attribute_history函数\n        with patch('quant_framework.jqdata.api.attribute_history') as mock_attr_hist:\n            mock_attr_hist.return_value = {\n                'close': [10.0, 10.5, 11.0, 10.8, 11.2]\n            }\n            \n            result = await jq_api.attribute_history(\n                security='000001.XSHE',\n                count=5,\n                unit='1d',\n                fields=['close']\n            )\n            \n            assert result is not None\n            assert 'close' in result\n            assert len(result['close']) == 5\n        \n        logger.info(\"聚宽兼容性集成测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_performance_monitoring_integration(self):\n        \"\"\"测试性能监控集成\"\"\"\n        logger.info(\"开始性能监控集成测试\")\n        \n        # 1. 测试性能指标收集\n        performance_metrics.counter('test_integration_counter', 1.0)\n        performance_metrics.gauge('test_integration_gauge', 100.0)\n        performance_metrics.histogram('test_integration_histogram', 0.5)\n        \n        # 2. 测试性能分析器\n        from quant_framework.performance.profiler import performance_profiler\n        \n        @performance_profiler.profile_function('test_integration_function')\n        def test_function():\n            time.sleep(0.01)\n            return sum(range(1000))\n        \n        result = test_function()\n        assert result == sum(range(1000))\n        \n        # 3. 验证指标收集\n        counter_summary = performance_metrics.get_metric_summary('test_integration_counter')\n        assert counter_summary is not None\n        assert counter_summary.count >= 1\n        \n        # 4. 验证性能分析\n        metrics = performance_profiler.get_metrics(name_filter='test_integration_function')\n        assert len(metrics) >= 1\n        assert metrics[0].duration > 0\n        \n        logger.info(\"性能监控集成测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_error_handling_integration(self):\n        \"\"\"测试错误处理集成\"\"\"\n        logger.info(\"开始错误处理集成测试\")\n        \n        async with get_async_session() as session:\n            strategy_service = StrategyService(session)\n            \n            # 1. 测试无效策略代码处理\n            invalid_strategy_data = {\n                'name': '无效策略',\n                'description': '用于测试错误处理',\n                'code': 'invalid python code',\n                'parameters': {}\n            }\n            \n            with pytest.raises(Exception):\n                await strategy_service.create_strategy(invalid_strategy_data, user_id=1)\n            \n            # 2. 测试不存在的数据请求\n            data_service = DataService(session)\n            \n            non_existent_data = await data_service.get_price_data(\n                symbol='NONEXISTENT',\n                start_date=date(2024, 1, 1),\n                end_date=date(2024, 1, 31)\n            )\n            \n            # 应该返回空列表而不是抛出异常\n            assert non_existent_data == []\n            \n            # 3. 测试缓存错误处理\n            # 模拟Redis连接失败\n            with patch.object(cache_manager, 'get', side_effect=Exception(\"Redis连接失败\")):\n                # 应该优雅地处理缓存失败\n                result = await cache_manager.get('test_key', default='default_value')\n                assert result == 'default_value'\n            \n            logger.info(\"错误处理集成测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_concurrent_operations_integration(self):\n        \"\"\"测试并发操作集成\"\"\"\n        logger.info(\"开始并发操作集成测试\")\n        \n        async def create_test_strategy(session, index):\n            \"\"\"创建测试策略\"\"\"\n            strategy_service = StrategyService(session)\n            \n            strategy_data = {\n                'name': f'并发测试策略_{index}',\n                'description': f'并发测试策略 {index}',\n                'code': 'def initialize(context): pass\\ndef handle_data(context, data): pass',\n                'parameters': {'index': index}\n            }\n            \n            return await strategy_service.create_strategy(strategy_data, user_id=1)\n        \n        # 并发创建多个策略\n        tasks = []\n        for i in range(5):\n            async with get_async_session() as session:\n                task = create_test_strategy(session, i)\n                tasks.append(task)\n        \n        strategies = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # 验证所有策略都创建成功\n        successful_strategies = [s for s in strategies if not isinstance(s, Exception)]\n        assert len(successful_strategies) >= 3  # 至少3个成功\n        \n        # 测试并发数据加载\n        async def load_test_data(symbol):\n            \"\"\"加载测试数据\"\"\"\n            return await async_data_loader.load_data(\n                key=f'test_data_{symbol}',\n                loader_func=lambda x: f'data_for_{x}',\n                x=symbol\n            )\n        \n        data_tasks = [load_test_data(f'SYMBOL_{i}') for i in range(10)]\n        data_results = await asyncio.gather(*data_tasks)\n        \n        assert len(data_results) == 10\n        assert all(f'data_for_SYMBOL_{i}' == data_results[i] for i in range(10))\n        \n        logger.info(\"并发操作集成测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_system_resource_usage(self):\n        \"\"\"测试系统资源使用\"\"\"\n        logger.info(\"开始系统资源使用测试\")\n        \n        import psutil\n        \n        # 记录初始资源使用\n        process = psutil.Process()\n        initial_memory = process.memory_info().rss / 1024 / 1024  # MB\n        initial_cpu = process.cpu_percent()\n        \n        # 执行一系列操作\n        async with get_async_session() as session:\n            data_service = DataService(session)\n            \n            # 大量数据操作\n            for i in range(100):\n                await cache_manager.set(f'resource_test_{i}', {'data': list(range(100))})\n                performance_metrics.counter('resource_test_counter', 1.0)\n                performance_metrics.histogram('resource_test_histogram', i * 0.01)\n        \n        # 检查资源使用\n        final_memory = process.memory_info().rss / 1024 / 1024  # MB\n        final_cpu = process.cpu_percent()\n        \n        memory_increase = final_memory - initial_memory\n        \n        logger.info(f\"内存使用增长: {memory_increase:.1f}MB\")\n        logger.info(f\"CPU使用率: {final_cpu:.1f}%\")\n        \n        # 资源使用应该在合理范围内\n        assert memory_increase < 100  # 内存增长不超过100MB\n        assert final_cpu < 80  # CPU使用率不超过80%\n        \n        logger.info(\"系统资源使用测试通过\")\n    \n    @pytest.mark.asyncio\n    async def test_system_recovery_integration(self):\n        \"\"\"测试系统恢复集成\"\"\"\n        logger.info(\"开始系统恢复集成测试\")\n        \n        # 1. 测试缓存恢复\n        await cache_manager.set('recovery_test', 'test_value')\n        \n        # 模拟缓存清空\n        await cache_manager.clear_all()\n        \n        # 验证缓存已清空\n        result = await cache_manager.get('recovery_test')\n        assert result is None\n        \n        # 重新设置缓存\n        await cache_manager.set('recovery_test', 'recovered_value')\n        result = await cache_manager.get('recovery_test')\n        assert result == 'recovered_value'\n        \n        # 2. 测试数据加载器恢复\n        await async_data_loader.stop()\n        await async_data_loader.start()\n        \n        # 验证数据加载器正常工作\n        result = await async_data_loader.load_data(\n            key='recovery_test_data',\n            loader_func=lambda: 'recovered_data'\n        )\n        assert result == 'recovered_data'\n        \n        # 3. 测试性能指标恢复\n        performance_metrics.clear_metrics()\n        \n        # 重新收集指标\n        performance_metrics.counter('recovery_test_counter', 1.0)\n        summary = performance_metrics.get_metric_summary('recovery_test_counter')\n        assert summary is not None\n        assert summary.count == 1\n        \n        logger.info(\"系统恢复集成测试通过\")\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"--tb=short\"])\n